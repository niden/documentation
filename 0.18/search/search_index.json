{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"arrays/","title":"Arrays","text":"<p>Array manipulation in Zephir provides a way to leverage PHP arrays. An array in Zephir corresponds to the concept of a hash table in other programming languages.</p>"},{"location":"arrays/#declaring-array-variables","title":"Declaring Array Variables","text":"<p>Array variables can be declared using the keywords <code>var</code> or <code>array</code>:</p> <pre><code>var a   = []; // array variable, its type can be changed\narray b = []; // array variable, its type cannot be changed across execution\n</code></pre>"},{"location":"arrays/#creating-arrays","title":"Creating Arrays","text":"<p>Arrays are created by enclosing elements in square brackets:</p>"},{"location":"arrays/#empty-array","title":"Empty array","text":"<pre><code>let elements = [];\n</code></pre>"},{"location":"arrays/#array-with-elements","title":"Array with elements","text":"<pre><code>let elements = [1, 3, 4];\n</code></pre>"},{"location":"arrays/#array-with-elements-of-different-types","title":"Array with elements of different types","text":"<pre><code>let elements = [\"first\", 2, true];\n</code></pre>"},{"location":"arrays/#multi-dimensional-array","title":"Multi-dimensional array","text":"<pre><code>let elements = [[0, 1], [4, 5], [2, 3]];\n</code></pre> <p>Zephir supports hashes or dictionaries, similar to PHP:</p>"},{"location":"arrays/#hash-with-string-keys","title":"Hash with string keys","text":"<pre><code>let elements = [\"foo\": \"bar\", \"bar\": \"foo\"];\n</code></pre>"},{"location":"arrays/#hash-with-numeric-keys","title":"Hash with numeric keys","text":"<pre><code>let elements = [4: \"bar\", 8: \"foo\"];\n</code></pre>"},{"location":"arrays/#hash-with-mixed-string-and-numeric-keys","title":"Hash with mixed string and numeric keys","text":"<pre><code>let elements = [4: \"bar\", \"foo\": 8];\n</code></pre>"},{"location":"arrays/#updating-arrays","title":"Updating arrays","text":"<p>Arrays are updated using square brackets:</p>"},{"location":"arrays/#string-key","title":"String key","text":"<pre><code>let elements[\"foo\"] = \"bar\";\n</code></pre>"},{"location":"arrays/#numeric-key","title":"Numeric key","text":"<pre><code>let elements[0] = \"bar\";\n</code></pre>"},{"location":"arrays/#multi-dimensional-array_1","title":"Multi-dimensional array","text":"<pre><code>let elements[0][\"foo\"] = \"bar\";\nlet elements[\"foo\"][0] = \"bar\";\n</code></pre>"},{"location":"arrays/#appending-elements","title":"Appending elements","text":"<p>Elements can be appended at the end of the array:</p> <pre><code>let elements[] = \"bar\";\n</code></pre>"},{"location":"arrays/#reading-elements-from-arrays","title":"Reading elements from arrays","text":"<p>Retrieve array elements using either string or numeric keys:</p>"},{"location":"arrays/#using-the-string-key","title":"Using the string key","text":"<pre><code>let foo = elements[\"foo\"];\n</code></pre>"},{"location":"arrays/#using-the-numeric-key","title":"Using the numeric key","text":"<pre><code>let foo = elements[0];\n</code></pre>"},{"location":"builtin-methods/","title":"Built-In Methods","text":"<p>As previously mentioned, Zephir strongly encourages object-oriented programming, allowing variables related to static types to be handled as objects.</p> <p>Consider the following two methods with the same functionality:</p> <pre><code>public function binaryToHex(string s) -&gt; string\n{\n    var o = \"\", n; char ch;\n\n    for ch in range(0, strlen(s)) {\n        let n = sprintf(\"%X\", ch);\n        if strlen(n) &lt; 2 {\n            let o .= \"0\" . n;\n        } else {\n            let o .= n;\n        }\n    }\n    return o;\n}\n</code></pre> <p>And:</p> <pre><code>public function binaryToHex(string s) -&gt; string\n{\n    var o = \"\", n; char ch;\n\n    for ch in range(0, s-&gt;length()) {\n        let n = ch-&gt;toHex();\n        if n-&gt;length() &lt; 2 {\n            let o .= \"0\" . n;\n        } else {\n            let o .= n;\n        }\n    }\n    return o;\n}\n</code></pre> <p>Both methods achieve the same result, but the second one embraces object-oriented programming. It's worth noting that calling methods on static-typed variables has no impact on performance, as Zephir internally transforms the code from the object-oriented version to the procedural version.</p>"},{"location":"builtin-methods/#string","title":"String","text":"<p>Zephir provides several built-in methods for string manipulation:</p> Object-Oriented Procedural Description <code>s-&gt;format()</code> <code>sprintf(s, \"%s\", x)</code> Return a formatted string <code>s-&gt;index(\"foo\")</code> <code>strpos(s, \"foo\")</code> Find the position of the first occurrence of a substring in a string <code>s-&gt;length()</code> <code>strlen(s)</code> Get string length <code>s-&gt;lower()</code> <code>strtolower(s)</code> Make a string lowercase <code>s-&gt;lowerfirst()</code> <code>lcfirst(s)</code> Make a string's first character lowercase <code>s-&gt;md5()</code> <code>md5(s)</code> Calculate the md5 hash of a string <code>s-&gt;sha1()</code> <code>sha1(s)</code> Calculate the sha1 hash of a string <code>s-&gt;trim()</code> <code>trim(s)</code> Strip whitespace (or other characters) from the beginning and end of a string <code>s-&gt;trimleft()</code> <code>ltrim(s)</code> Strip whitespace (or other characters) from the beginning of a string <code>s-&gt;trimright()</code> <code>rtrim(s)</code> Strip whitespace (or other characters) from the end of a string <code>s-&gt;upper()</code> <code>strtoupper(s)</code> Make a string uppercase <code>s-&gt;upperfirst()</code> <code>ucfirst(s)</code> Make a string's first character uppercase"},{"location":"builtin-methods/#array","title":"Array","text":"<p>Zephir also offers built-in methods for array manipulation:</p> Object-Oriented Procedural Description <code>a-&gt;combine(b)</code> <code>array_combine(a, b)</code> Creates an array by using one array for keys and another for its values <code>a-&gt;diff()</code> <code>array_diff(a)</code> Computes the difference of arrays <code>a-&gt;flip()</code> <code>array_flip(a)</code> Exchanges all keys with their associated values in an array <code>a-&gt;hasKey()</code> <code>array_key_exists(a)</code> Checks if the given key or index exists in the array <code>a-&gt;intersect(b)</code> <code>array_intersect(a, b)</code> Computes the intersection of arrays <code>a-&gt;join(\" \")</code> <code>join(\" \", a)</code> Join array elements with a string <code>a-&gt;keys()</code> <code>array_keys(a)</code> Return all the keys or a subset of the keys of an array <code>a-&gt;merge(b)</code> <code>array_merge(a, b)</code> Merge one or more arrays <code>a-&gt;pad()</code> <code>array_pad(a, b)</code> Pad array to the specified length with a value <code>a-&gt;rev()</code> <code>array_reverse(a)</code> Return an array with elements in reverse order <code>a-&gt;reversed()</code> <code>array_reverse(a)</code> Return an array with elements in reverse order <code>a-&gt;split()</code> <code>array_chunk(a)</code> Split an array into chunks <code>a-&gt;values()</code> <code>array_values(a)</code> Return all the values of an array <code>a-&gt;walk()</code> <code>array_walk(a)</code> Apply a user supplied function to every member of an array"},{"location":"builtin-methods/#char","title":"Char","text":"<p>For character manipulation, Zephir provides:</p> OO Procedural <code>ch-&gt;toHex()</code> <code>sprintf(\"%X\", ch)</code>"},{"location":"builtin-methods/#integer","title":"Integer","text":"<p>For integer manipulation, Zephir includes:</p> OO Procedural <code>i-&gt;abs()</code> <code>abs(i)</code>"},{"location":"closures/","title":"Closures","text":"<p>Zephir supports closures, also known as anonymous functions, which are PHP-compatible and can be seamlessly utilized in Zephir. These closures can be returned to the PHP userland.</p> <p>Consider the following example:</p> <pre><code>namespace MyLibrary;\n\nclass Functional\n{\n\n    public function map(array! data)\n    {\n        return function(number) {\n            return number * number;\n        };\n    }\n}\n</code></pre> <p>In this example, a closure is defined within the map method, taking a number as a parameter and returning its square.</p> <p>Closures can also be executed directly within Zephir and passed as parameters to other functions/methods:</p> <pre><code>namespace MyLibrary;\n\nclass Functional\n{\n\n    public function map(array! data)\n    {\n        return data-&gt;map(function(number) {\n            return number * number;\n        });\n    }\n}\n</code></pre> <p>Here, the closure is employed within the map function, applying the defined transformation to each element of the array.</p> <p>Additionally, Zephir provides a concise syntax for defining closures:</p> <pre><code>namespace MyLibrary;\n\nclass Functional\n{\n\n    public function map(array! data)\n    {\n        return data-&gt;map(number =&gt; number * number);\n    }\n}\n</code></pre> <p>The short syntax offers a more compact way to express closures, enhancing code readability.</p>"},{"location":"command-line/","title":"The Zephir Command Line","text":"<p>After installing Zephir, you can use the <code>zephir</code> command to manage the Zephir compiler for your projects. This chapter provides an overview of the command and its various functionalities.</p> <p>As of Zephir 0.11.7, the compiler uses <code>stderr</code> for displaying error messages, allowing you to handle error outputs separately from normal ones, as shown below:</p> <pre><code>zephir generate 2&gt; errors.log 1&gt; /dev/null\n</code></pre>"},{"location":"command-line/#zephir-api","title":"<code>zephir api</code>","text":"<p>Generates an HTML API based on the classes exposed in the extension</p> <ul> <li><code>--backend=BACKEND</code>:                 Backend used to generate HTML API (default: <code>ZendEngine3</code>)</li> <li><code>--path=PATH</code> (or <code>-p PATH</code>):        The API theme to be used</li> <li><code>--output=OUTPUT</code> (or <code>-o OUTPUT</code>):  Output directory to generate theme</li> <li><code>--options=OPTIONS</code>:                 Theme options</li> <li><code>--url=URL</code>:                         The base URL to be used when generating links</li> </ul>"},{"location":"command-line/#zephir-build","title":"<code>zephir build</code>","text":"<p>A meta command that calls the <code>generate</code>, <code>compile</code>, and <code>install</code> commands. Check those commands for more information on supported options and behaviors for each.</p>"},{"location":"command-line/#zephir-clean","title":"<code>zephir clean</code>","text":"<p>Cleans any object files created by the extension</p>"},{"location":"command-line/#zephir-compile","title":"<code>zephir compile</code>","text":"<p>Compile a Zephir extension</p> <ul> <li><code>--backend=BACKEND</code>:                 Backend used to build extension (default: <code>ZendEngine3</code>)</li> <li><code>--dev</code>:                             Build the extension in development mode</li> <li><code>--no-dev</code>:                          Build the extension in production mode</li> </ul> <p>Using the <code>--dev</code> option forces building and installing the extension in development mode, including debug symbols and no optimizations. The <code>--no-dev</code> option ensures a production-ready extension, even if the PHP binary was compiled in a debug configuration.</p> <p>Additionally, options available under <code>extra</code> in the configuration file can be passed here, such as <code>--export-classes</code> and <code>--indent=tabs</code>.</p> <p>NOTE</p> <p>Zephir development mode will be enabled silently if your PHP binary was compiled in a debug configuration.</p>"},{"location":"command-line/#zephir-fullclean","title":"<code>zephir fullclean</code>","text":"<p>Cleans any object files created by the extension (including files generated by phpize)</p>"},{"location":"command-line/#zephir-generate","title":"<code>zephir generate</code>","text":"<p>Generates C code from the Zephir code</p> <ul> <li><code>--backend=BACKEND</code>:                 Backend used to build extension (default: <code>ZendEngine3</code>)</li> </ul>"},{"location":"command-line/#zephir-help","title":"<code>zephir help</code>","text":"<p>Displays help for a command</p>"},{"location":"command-line/#zephir-init","title":"<code>zephir init</code>","text":"<p>Initializes a Zephir extension <code>zephir init &lt;namespace&gt;</code></p> <ul> <li><code>namespace</code>:                         The extension namespace</li> <li><code>--backend=BACKEND</code>:                 Backend used to create extension (default: <code>ZendEngine3</code>)</li> </ul>"},{"location":"command-line/#zephir-install","title":"<code>zephir install</code>","text":"<p>Installs the extension in the extension directory (may require root password)</p> <ul> <li><code>--dev</code>:                             Install the extension in development mode</li> <li><code>--no-dev</code>:                          Install the extension in production mode</li> </ul>"},{"location":"command-line/#zephir-list","title":"<code>zephir list</code>","text":"<p>Lists commands</p>"},{"location":"command-line/#zephir-stubs","title":"<code>zephir stubs</code>","text":"<p>Generates stubs that can be used in a PHP IDE</p> <ul> <li><code>--backend=BACKEND</code>:                 Backend used to generate stubs (default: <code>ZendEngine3</code>)</li> </ul>"},{"location":"config/","title":"Configuration File","text":"<p>Every Zephir extension has a configuration file called <code>config.json</code>. Zephir reads this file every time you build or generate the extension, allowing you to modify the extension's or compiler's behavior. The configuration file uses JSON as its format:</p> <pre><code>{\n    \"namespace\": \"test\",\n    \"name\": \"Test Extension\",\n    \"description\": \"My amazing extension\",\n    \"author\": \"Tony Hawk\",\n    \"version\": \"1.2.0\"\n}\n</code></pre> <p>Settings defined in this file override any factory default setting provided by Zephir.</p> <p>The following settings are supported:</p>"},{"location":"config/#api","title":"api","text":"<p>Used to configure the automatically generated HTML documentation for your extension. <code>path</code> specifies where to create the documentation relative to the project root. <code>base-url</code> is used to generate a <code>sitemap.xml</code> file for your documentation. <code>theme</code> is used to set the theme used for the generated documentation (via the <code>name</code> setting), and any options the theme supports passing (via the <code>options</code> setting). Finally, <code>theme-directories</code> is used to provide additional search paths for finding your desired theme.:</p> <pre><code>{\n    \"api\": {\n        \"path\": \"doc/%version%\",\n        \"base-url\": \"http://example.local/api/\",\n        \"theme\": {\n            \"name\"   : \"zephir\",\n            \"options\": {\n                \"github\":           null,\n                \"analytics\":        null,\n                \"main_color\":       \"#3E6496\",\n                \"link_color\":       \"#3E6496\",\n                \"link_hover_color\": \"#5F9AE7\"\n            }\n        },\n        \"theme-directories\": [\n            \"my/api/themes\"\n        ]\n    }\n}\n</code></pre>"},{"location":"config/#author","title":"author","text":"<p>Company, developer, institution, etc that developed the extension:</p> <pre><code>{\n    \"author\": \"Tony Hawk\"\n}\n</code></pre>"},{"location":"config/#backend","title":"backend","text":"<p>Provides a way to configure the Zend Engine backend used by your extension. At the moment, only the <code>templatepath</code>, which lets you select between <code>ZendEngine2</code> and <code>ZendEngine3</code>, is supported:</p> <pre><code>{\n    \"backend\": {\n        \"templatepath\": \"ZendEngine3\"\n    }\n}\n</code></pre>"},{"location":"config/#constants-sources","title":"constants-sources","text":"<p>To import just the constants in a C source file into your project, list the file's path in this setting:</p> <pre><code>{\n    \"constants-sources\": [\n        \"utils/math_constants.h\"\n    ]\n}\n</code></pre>"},{"location":"config/#description","title":"description","text":"<p>Extension description - any text describing your extension:</p> <pre><code>{\n    \"description\": \"My amazing extension\"\n}\n</code></pre>"},{"location":"config/#destructors","title":"destructors","text":"<p>This setting lets you provide one or more C functions to be executed on certain extension lifecycle events - specifically, <code>RSHUTDOWN</code> (<code>request</code>), <code>PRSHUTDOWN</code> (<code>post-request</code>), <code>MSHUTDOWN</code> (<code>module</code>), and <code>GSHUTDOWN</code> (<code>globals</code>). Check the lifecycle hooks chapter for more information.</p> <pre><code>{\n    \"destructors\": [\n        {\n            \"request\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"c_function_for_shutting_down(TSRMLS_C)\"\n                },\n                {\n                    \"include\": \"my/awful/library.h\",\n                    \"code\": \"some_other_c_function_than_the_other_ones(TSRMLS_C)\"\n                }\n            ],\n            \"post-request\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"c_function_for_cleaning_up_after_the_response_is_sent(TSRMLS_C)\"\n                }\n            ],\n            \"module\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"release_module_deps(TSRMLS_C)\"\n                }\n            ],\n            \"globals\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"release_globals_deps(TSRMLS_C)\"\n                }\n            ]\n        }\n    ]\n}\n</code></pre>"},{"location":"config/#extension-name","title":"extension-name","text":"<p>The base filename of the extension. It must follow the same rules as the <code>namespace</code> setting, which is used as a fallback if this one isn't given.</p> <pre><code>{\n    \"extension-name\": \"test\"\n}\n</code></pre>"},{"location":"config/#external-dependencies","title":"external-dependencies","text":"<p>You can include a class from another namespace/extension directly in your own extension by configuring it here:</p> <pre><code>{\n    \"external-dependencies\": {\n        \"My\\\\Awesome\": \"my/awesome/class.zep\",\n        \"My\\\\Awful\": \"my/awful/class.zep\"\n    }\n}\n</code></pre>"},{"location":"config/#extra","title":"extra","text":"<p>Contains extra settings that also can be passed, as is, on the command line. Currently, that's <code>export-clases</code> (generate headers for accessing your classes from other C code), and <code>indent</code> (select between using <code>tabs</code> or <code>spaces</code> to indent code in generated files):</p> <pre><code>{\n    \"extra\": {\n        \"export-classes\": true,\n        \"indent\": \"tabs\"\n    }\n}\n</code></pre>"},{"location":"config/#extra-cflags","title":"extra-cflags","text":"<p>Any additional flags you want to add to the compilation process:</p> <pre><code>{\n    \"extra-cflags\": \"-I/usr/local/Cellar/libevent/2.0.21_1/include\"\n}\n</code></pre>"},{"location":"config/#extra-classes","title":"extra-classes","text":"<p>If you already have a PHP class implemented in C, you can include it directly in your extension by configuring it here:</p> <pre><code>{\n    \"extra-classes\": [\n        {\n            \"header\": \"utls/old_c_class/class.h\",\n            \"source\": \"utils/old_c_class/class.c\",\n            \"init\": \"old_c_class\",\n            \"entry\": \"old_c_class_ce\"\n        }\n    ]\n}\n</code></pre>"},{"location":"config/#extra-libs","title":"extra-libs","text":"<p>Any additional libraries you want to add to the compilation process:</p> <pre><code>{\n    \"extra-libs\": \"-L/usr/local/Cellar/libevent/2.0.21_1/lib -levent\"\n}\n</code></pre>"},{"location":"config/#extra-sources","title":"extra-sources","text":"<p>Any additional files you want to add to the compilation process - the search directory is relative to the <code>ext</code> folder of your project:</p> <pre><code>{\n    \"extra-sources\": [\n        \"utils/pi.c\"\n    ]\n}\n</code></pre>"},{"location":"config/#globals","title":"globals","text":"<p>Extension globals available. Check the globals chapter for more information.</p> <pre><code>{\n    \"globals\": {\n        \"my_setting_1\": {\n            \"type\": \"bool\",\n            \"default\": true\n        },\n        \"my_setting_2\": {\n            \"type\": \"int\",\n            \"default\": 10\n        }\n    }\n}\n</code></pre>"},{"location":"config/#info","title":"info","text":"<p><code>phpinfo()</code> sections. Check the phpinfo() chapter for more information.</p> <pre><code>{\n    \"info\": [\n        {\n            \"header\": [\"Directive\", \"Value\"],\n            \"rows\": [\n                [\"setting1\", \"value1\"],\n                [\"setting2\", \"value2\"]\n            ]\n        }\n    ]\n}\n</code></pre>"},{"location":"config/#initializers","title":"initializers","text":"<p>This setting lets you provide one or more C functions to be executed on certain extension lifecycle events - specifically, <code>GINIT</code> (<code>globals</code>), <code>MINIT</code> (<code>module</code>), and <code>RINIT</code> (<code>request</code>). Check the lifecycle hooks chapter for more information.</p> <pre><code>{\n    \"initializers\": [\n        {\n            \"globals\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"setup_globals_deps(TSRMLS_C)\"\n                }\n            ],\n            \"module\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"setup_module_deps(TSRMLS_C)\"\n                }\n            ],\n            \"request\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"some_c_function(TSRMLS_C)\"\n                },\n                {\n                    \"include\": \"my/awful/library.h\",\n                    \"code\": \"some_other_c_function(TSRMLS_C)\"\n                }\n            ]\n        }\n    ]\n}\n</code></pre>"},{"location":"config/#name","title":"name","text":"<p>Extension name used in compiled C code - can only contain ascii characters:</p> <pre><code>{\n    \"name\": \"test\"\n}\n</code></pre>"},{"location":"config/#namespace","title":"namespace","text":"<p>The namespace of the extension - it must be a simple identifier respecting the regular expression <code>[a-zA-Z0-9\\_]+</code>:</p> <pre><code>{\n    \"namespace\": \"test\"\n}\n</code></pre>"},{"location":"config/#optimizations","title":"optimizations","text":"<p>Compiler optimizations which should be enabled or disabled in the current project:</p> <pre><code>{\n    \"optimizations\": {\n        \"static-type-inference\": true,\n        \"static-type-inference-second-pass\": true,\n        \"local-context-pass\": false\n    }\n}\n</code></pre>"},{"location":"config/#optimizer-dirs","title":"optimizer-dirs","text":"<p>The directories where your own optimizers can be found - the search directory is relative to the root folder of your project:</p> <pre><code>{\n    \"optimizer-dirs\": [\n        \"optimizers\"\n    ]\n}\n</code></pre>"},{"location":"config/#package-dependencies","title":"package-dependencies","text":"<p>Declare library dependencies (version constraints will be checked by <code>pkg-config</code>, and can use one of the operators <code>=</code>, <code>&gt;=</code>, <code>&lt;=</code>, or <code>*</code>):</p> <pre><code>{\n    \"package-dependencies\": {\n        \"openssl\": \"*\",\n        \"libpng\": \"&gt;= 0.1.0\",\n        \"protobuf\": \"&lt;= 2.6.1\"\n    }\n}\n</code></pre>"},{"location":"config/#prototype-dir","title":"prototype-dir","text":"<p>Allows you to provide prototype files describing other extensions required to build your own, so they don't necessarily need to be installed during the build phase:</p> <pre><code>{\n    \"prototype-dir\": {\n        \"igbinary\": \"prototypes\",\n        \"session\": \"prototypes\"\n    }\n}\n</code></pre>"},{"location":"config/#requires","title":"requires","text":"<p>Allows you to list other extensions as required to build/use your own:</p> <pre><code>{\n    \"requires\": {\n        \"extensions\": [\n            \"igbinary\",\n            \"session\"\n        ]\n    }\n}\n</code></pre>"},{"location":"config/#silent","title":"silent","text":"<p>Suppresses most/all output from <code>zephir</code> commands (same as <code>-q</code> or <code>--quiet</code>):</p> <pre><code>{\n    \"silent\": false\n}\n</code></pre>"},{"location":"config/#stubs","title":"stubs","text":"<p>This setting allows adjusting the way IDE documentation stubs are generated. <code>path</code> sets where the stubs should be created, while <code>stubs-run-after-generate</code> sets whether to automatically (re)build the stubs when your code is compiled to C:</p> <pre><code>{\n    \"stubs\": {\n        \"path\": \"ide/%version%/%namespace%/\",\n        \"stubs-run-after-generate\": false\n    }\n}\n</code></pre>"},{"location":"config/#verbose","title":"verbose","text":"<p>Displays more detail in error messages from exceptions generated by <code>zephir</code> commands (can also enable with <code>-v</code>, or disable with <code>-V</code>):</p> <pre><code>{\n    \"verbose\": false\n}\n</code></pre>"},{"location":"config/#version","title":"version","text":"<p>Extension version - must follow the regular expression <code>[0-9]+\\.[0-9]+\\.[0-9]+</code>:</p> <pre><code>{\n    \"version\": \"1.2.0\"\n}\n</code></pre>"},{"location":"config/#warnings","title":"warnings","text":"<p>Compiler warnings which should be enabled or disabled in the current project:</p> <pre><code>{\n    \"warnings\": {\n        \"unused-variable\": true,\n        \"unused-variable-external\": false,\n        \"possible-wrong-parameter\": true,\n        \"possible-wrong-parameter-undefined\": false,\n        \"nonexistent-function\": true,\n        \"nonexistent-class\": true\n    }\n}\n</code></pre>"},{"location":"control-structures/","title":"Control Structures","text":"<p>Zephir implements a simplified set of control structures present in similar languages like C, PHP etc.</p>"},{"location":"control-structures/#conditionals","title":"Conditionals","text":""},{"location":"control-structures/#if-statement","title":"If Statement","text":"<p><code>if</code> statements evaluate an expression, executing the following block if the evaluation is <code>true</code>. Braces are required. An <code>if</code> can have an optional <code>else</code> clause, and multiple <code>if</code>/<code>else</code> constructs can be chained together:</p> <pre><code>if false {\n    echo \"false?\";\n} else {\n    if true {\n        echo \"true!\";\n    } else {\n        echo \"neither true nor false\";\n    }\n}\n</code></pre> <p><code>elseif</code> clauses are also available:</p> <pre><code>if a &gt; 100 {\n    echo \"to big\";\n} elseif a &lt; 0 {\n    echo \"to small\";\n} elseif a == 50 {\n    echo \"perfect!\";\n} else {\n    echo \"ok\";\n}\n</code></pre> <p>Parentheses in the evaluated expression are optional:</p> <pre><code>if a &lt; 0 { return -1; } else { if a &gt; 0 { return 1; } }\n</code></pre>"},{"location":"control-structures/#switch-statement","title":"Switch Statement","text":"<p>A <code>switch</code> evaluates an expression against a series of predefined literal values, executing the corresponding <code>case</code> block or falling back to the <code>default</code> block case:</p> <pre><code>switch count(items) {\n\n    case 1:\n    case 3:\n        echo \"odd items\";\n        break;\n\n    case 2:\n    case 4:\n        echo \"even items\";\n        break;\n\n    default:\n        echo \"unknown items\";\n}\n</code></pre>"},{"location":"control-structures/#loops","title":"Loops","text":""},{"location":"control-structures/#while-statement","title":"While Statement","text":"<p><code>while</code> denotes a loop that iterates as long as its given condition evaluates as <code>true</code>:</p> <pre><code>let counter = 5;\nwhile counter {\n    let counter -= 1;\n}\n</code></pre>"},{"location":"control-structures/#loop-statement","title":"Loop Statement","text":"<p>In addition to <code>while</code>, <code>loop</code> can be used to create infinite loops:</p> <pre><code>let n = 40;\nloop {\n    let n -= 2;\n    if n % 5 == 0 { break; }\n    echo x, \"\\n\";\n}\n</code></pre>"},{"location":"control-structures/#for-statement","title":"For Statement","text":"<p>A <code>for</code> is a control structure that allows to traverse arrays or strings:</p> <pre><code>for item in [\"a\", \"b\", \"c\", \"d\"] {\n    echo item, \"\\n\";\n}\n</code></pre> <p>Keys in hashes can be obtained by providing a variable for both the key and value:</p> <pre><code>let items = [\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4];\n\nfor key, value in items {\n    echo key, \" \", value, \"\\n\";\n}\n</code></pre> <p>A <code>for</code> loop can also be instructed to traverse an array or string in reverse order:</p> <pre><code>let items = [1, 2, 3, 4, 5];\n\nfor value in reverse items {\n    echo value, \"\\n\";\n}\n</code></pre> <p>A <code>for</code> loop can be used to traverse string variables:</p> <pre><code>string language = \"zephir\"; char ch;\n\nfor ch in language {\n    echo \"[\", ch ,\"]\";\n}\n</code></pre> <p>In reverse order:</p> <pre><code>string language = \"zephir\"; char ch;\n\nfor ch in reverse language {\n    echo \"[\", ch ,\"]\";\n}\n</code></pre> <p>A standard <code>for</code> that traverses a range of integer values can be written as follows:</p> <pre><code>for i in range(1, 10) {\n    echo i, \"\\n\";\n}\n</code></pre> <p>To avoid warnings about unused variables, you can use anonymous variables in <code>for</code> statements, by replacing a variable name with the placeholder <code>_</code>:</p>"},{"location":"control-structures/#use-the-key-but-ignore-the-value","title":"Use the key but ignore the value","text":"<pre><code>for key, _ in data {\n    echo key, \"\\n\";\n}\n</code></pre>"},{"location":"control-structures/#break-statement","title":"Break Statement","text":"<p><code>break</code> ends execution of the current <code>while</code>, <code>for</code> or <code>loop</code> statement:</p> <pre><code>for item in [\"a\", \"b\", \"c\", \"d\"] {\n    if item == \"c\" {\n        break; // exit the for\n    }\n    echo item, \"\\n\";\n}\n</code></pre>"},{"location":"control-structures/#continue-statement","title":"Continue Statement","text":"<p><code>continue</code> is used within looping structures to skip the rest of the current loop iteration and continue execution at the condition evaluation, and then the beginning of the next iteration.</p> <pre><code>let a = 5;\nwhile a &gt; 0 {\n    let a--;\n    if a == 3 {\n        continue;\n    }\n    echo a, \"\\n\";\n}\n</code></pre>"},{"location":"control-structures/#require","title":"Require","text":"<p>The <code>require</code> statement dynamically includes and evaluates a specified PHP file. Note that files included via Zephir are interpreted by Zend Engine as normal PHP files. <code>require</code> does not allow Zephir code to include other Zephir files at runtime.</p> <pre><code>if file_exists(path) {\n    require path;\n}\n</code></pre>"},{"location":"control-structures/#let","title":"Let","text":"<p>The <code>let</code> statement is used to mutate variables, properties and arrays. Variables are by default immutable and this instruction makes them mutable for the duration of the statement:</p> <pre><code>let name = \"Tony\";           // simple variable\nlet this-&gt;name = \"Tony\";     // object property\nlet data[\"name\"] = \"Tony\";   // array index\nlet self::_name = \"Tony\";    // static property\n</code></pre> <p>Also this instruction must be used to increment/decrement variables:</p> <pre><code>let number++;           // increment simple variable\nlet number--;           // decrement simple variable\nlet this-&gt;number++;     // increment object property\nlet this-&gt;number--;     // decrement object property\n</code></pre> <p>Multiple mutations can be performed in a single <code>let</code> operation:</p> <pre><code>let price = 1.00, realPrice = price, status = false;\n</code></pre>"},{"location":"exceptions/","title":"Exceptions","text":"<p>Zephir implements exceptions at a very low level, providing similar behavior and functionality to PHP.</p> <p>When an exception is thrown, a <code>catch</code> block can be used to capture the exception and allow the developer to provide proper handling.</p> <p>Exceptions can be thrown inside the <code>try</code> block. Handling happens in the <code>catch</code> block, exactly as in PHP:</p> <pre><code>var e;\ntry {\n\n    throw new \\Exception(\"This is an exception\");\n\n} catch \\Exception, e {\n\n    echo e-&gt;getMessage();\n}\n</code></pre> <p>Zephir also provides a \"silent\" <code>try</code> block, that simply ignores any exceptions produced within that block:</p> <pre><code>try {\n    throw new \\Exception(\"This is an exception\");\n}\n</code></pre> <p>If you don't need an exception variable when 'catch'ing, then you can safely not provide it:</p> <pre><code>try {\n\n    throw new \\Exception(\"This is an exception\");\n\n} catch \\Exception {\n\n    echo \"An exception occur!\";\n}\n</code></pre> <p>A single <code>catch</code> block can be used to catch multiple types of exception:</p> <pre><code>var e;\ntry {\n\n    throw new \\Exception(\"This is an exception\");\n\n} catch \\RuntimeException|\\Exception, e {\n\n    echo e-&gt;getMessage();\n}\n</code></pre> <p>Zephir allows you to throw literals or static typed variables as if they were the message of the exception:</p> <pre><code>// throw new \\Exception(\"Test\");\nthrow \"Test\";\n\n// throw new \\Exception((string) 't');\nthrow 't';\n\n// throw new \\Exception((string) 123);\nthrow 123;\n\n// throw new \\Exception((string) 123.123);\nthrow 123.123;\n</code></pre> <p>Zephir's exceptions provide the same methods to know where the exception happened that PHP's exceptions do. That is, <code>Exception::getFile()</code> and <code>Exception::getLine()</code> return the location in the Zephir code where the exception was thrown:</p> <pre><code>Exception: The static method 'someMethod' does not exist on model 'Robots'\nFile=phalcon/mvc/model.zep Line=4042\n#0 /home/scott/test.php(64): Phalcon\\Mvc\\Model::__callStatic('someMethod', Array)\n#1 /home/scott/test.php(64): Robots::someMethod()\n#2 {main}\n</code></pre>"},{"location":"functions/","title":"Calling Functions","text":"<p>In Zephir, you can call PHP functions directly within your code. Here's an example:</p> <pre><code>namespace MyLibrary;\n\nclass Encoder\n{\n    public function encode(var text)\n    {\n        if strlen(text) != 0 {\n            return base64_encode(text);\n        }\n        return false;\n    }\n}\n</code></pre> <p>You can also call functions that are expected to exist in the PHP userland, but are not necessarily built in to PHP itself:</p> <pre><code>namespace MyLibrary;\n\nclass Encoder\n{\n\n    public function encode(var text)\n    {\n        if strlen(text) != 0 {\n            if function_exists(\"my_custom_encoder\") {\n                return my_custom_encoder(text);\n            } else {\n                return base64_encode(text);\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <p>Remember that PHP functions expect and return dynamic variables. If you pass a statically typed variable, Zephir automatically creates a temporary dynamic variable to facilitate the function call:</p> <pre><code>namespace MyLibrary;\n\nclass Encoder\n{\n    public function encode(string text)\n    {\n        if strlen(text) != 0 {\n            // an implicit dynamic variable is created to\n            // pass the static typed 'text' as parameter\n            return base64_encode(text);\n        }\n        return false;\n    }\n}\n</code></pre> <p>When functions return dynamic values, explicit casting is needed to assign them to static variables:</p> <pre><code>namespace MyLibrary;\n\nclass Encoder\n{\n    public function encode(string text)\n    {\n        string encoded = \"\";\n\n        if strlen(text) != 0 {\n            let encoded = (string) base64_encode(text);\n            return \"(\" . encoded . \")\";\n        }\n        return false;\n    }\n}\n</code></pre> <p>Zephir also supports dynamic function calls:</p> <pre><code>namespace MyLibrary;\n\nclass Encoder\n{\n    public function encode(var callback, string text)\n    {\n        return {callback}(text);\n    }\n}\n</code></pre>"},{"location":"globals/","title":"Extension Globals","text":"<p>In Zephir, extension globals provide a way to define and manage global variables within an extension. These globals are designed for simple scalar types such as <code>int</code>, <code>bool</code>, <code>double</code>, <code>char</code>, etc. It's a mechanism to set up configuration options that can influence the behavior of your library.</p> <p>To enable extension globals, you need to add a specific structure to your <code>config.json</code>:</p> <pre><code>{\n    \"globals\": {\n        \"allow_some_feature\": {\n            \"type\": \"bool\",\n            \"default\": true,\n            \"module\": true\n        },\n        \"number_times\": {\n            \"type\": \"int\",\n            \"default\": 10\n        },\n        \"some_component.my_setting_1\": {\n            \"type\": \"bool\",\n            \"default\": true\n        },\n        \"some_component.my_setting_2\": {\n            \"type\": \"int\",\n            \"default\": 100\n        }\n    }\n}\n</code></pre> <p>Each global has the following structure:</p> <pre><code>\"&lt;global-name&gt;\": {\n    \"type\": \"&lt;some-valid-type&gt;\",\n    \"default\": &lt;some-compatible-default-value&gt;\n}\n</code></pre> <p>For compound (namespaced) globals:</p> <pre><code>\"&lt;namespace&gt;.&lt;global-name&gt;\": {\n    \"type\": \"&lt;some-valid-type&gt;\",\n    \"default\": &lt;some-compatible-default-value&gt;\n}\n</code></pre> <p>The optional <code>module</code> key, if present, places the global's initialization process into the module-wide <code>GINIT</code> lifecycle event. This means it is set up only once per PHP process, rather than being reinitialized for every request, which is the default.</p> <pre><code>{\n    \"globals\": {\n        \"allow_some_feature\": {\n            \"type\": \"bool\",\n            \"default\": true,\n            \"module\": true\n        },\n        \"number_times\": {\n            \"type\": \"int\",\n            \"default\": 10\n        }\n    }\n}\n</code></pre> <p>In the example above, <code>allow_some_feature</code> is set up only once at startup; <code>number_times</code> is set up at the start of each request.</p> <p>Inside any method, you can read/write extension globals using the built-in functions <code>globals_get</code>/<code>globals_set</code>:</p> <pre><code>globals_set(\"allow_some_feature\", true);\nlet someFeature = globals_get(\"allow_some_feature\");\n</code></pre> <p>To modify these globals from PHP, you can create a method for this purpose:</p> <pre><code>namespace Test;\n\nclass MyOptions\n{\n    public static function setOptions(array options)\n    {\n        boolean someOption, anotherOption;\n\n        if fetch someOption, options[\"some_option\"] {\n            globals_set(\"some_option\", someOption);\n        }\n\n        if fetch anotherOption, options[\"another_option\"] {\n            globals_set(\"another_option\", anotherOption);\n        }\n    }\n}\n</code></pre> <p>Note that extension globals cannot be dynamically accessed, as the C code generated by the <code>globals_get</code>/<code>globals_set</code> optimizers must be resolved at compilation time:</p> <pre><code>let myOption = \"someOption\";\n\n// will throw a compiler exception\nlet someOption = globals_get(myOption);\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>To install Zephir, please follow these steps:</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before building a PHP extension with Zephir, ensure you have the following requirements:</p> <ul> <li>Zephir parser &gt;= 1.3.0</li> <li>A C compiler such as gcc &gt;= 4.4 or an alternative such as clang &gt;= 3.0, Visual C++ &gt;= 11 or Intel C++. It is recommended to use <code>gcc</code> 4.4 or later</li> <li>re2c 0.13.6 or later</li> <li>PHP development headers and tools</li> </ul> <p>For Linux based systems you'll need also: * GNU make 3.81 or later * autoconf 2.31 or later * automake 1.14 or later * libpcre3 * The <code>build-essential</code> package when using <code>gcc</code> on Ubuntu (and likely in other distributions as well)</p> <p>On Ubuntu, you can install the required packages with:</p> <pre><code>sudo apt-get update\nsudo apt-get install git gcc make re2c php php-json php-dev libpcre3-dev build-essential\n</code></pre> <p>Ensure you have a recent version of PHP installed and available in your console:</p> <pre><code>php -v\nPHP 8.0.30 (cli) (built: Nov 21 2023 16:16:21) ( NTS )\nCopyright (c) The PHP Group\nZend Engine v4.0.30, Copyright (c) Zend Technologies\n    with Xdebug v3.3.1, Copyright (c) 2002-2023, by Derick Rethans\n</code></pre> <p>Additionally, check that the PHP development libraries are installed:</p> <pre><code>phpize -v\nConfiguring for:\nPHP Api Version:         20200930\nZend Module Api No:      20200930\nZend Extension Api No:   420200930\n</code></pre> <p>You don't have to necessarily see the exact above output, but it's important that these commands are available to start developing with Zephir.</p>"},{"location":"installation/#installing-zephir","title":"Installing Zephir","text":"<p>First make sure that the Zephir parser extension is installed and activated. You can find installation instructions in the Zephir Parser repository.</p>"},{"location":"installation/#composer","title":"Composer","text":"<p>The recommended installation method is using composer:</p> <pre><code>composer require phalcon/zephir\n</code></pre> <p>Make sure that <code>${COMPOSER_HOME}/vendor/bin</code> is in your <code>$PATH</code>, to have Zephir should be available as <code>zephir</code> on the command line.</p>"},{"location":"installation/#project","title":"Project","text":"<p>Use <code>composer exec zephir</code> within the project you installed Zephir in, above, to run it. (Alternately, you can still run <code>vendor/bin/zephir</code>.)</p>"},{"location":"installation/#global","title":"Global","text":"<p>For a global installation, you can use:</p> <pre><code>composer global require phalcon/zephir\n</code></pre>"},{"location":"installation/#release-phar","title":"Release PHAR","text":"<p>You can also download the latest release PHAR from GitHub. Place it in your <code>$PATH</code> and consider renaming it to <code>zephir</code> for convenience.</p>"},{"location":"installation/#git-clone","title":"Git Clone","text":"<p>Clone the latest tag from GitHub, install dependencies, and run Zephir from there:</p> <pre><code>git clone --depth 1 -b $(git ls-remote https://github.com/zephir-lang/zephir 0.18.* | sort -t/ -k3 -Vr | head -n1 | awk -F/ '{ print $NF }') https://github.com/zephir-lang/zephir\ncomposer install\n</code></pre> <p>Either use the path to <code>zephir/zephir</code> or create a symlink in a directory in your <code>$PATH</code> to run Zephir using this option.</p>"},{"location":"installation/#testing-the-installation","title":"Testing the Installation","text":"<p>Check if Zephir is available from any directory by executing:</p> <pre><code>zephir help\n</code></pre>"},{"location":"introduction/","title":"Introducing Zephir","text":"<p>Welcome to Zephir, an open-source, high-level/domain-specific language designed to facilitate the creation and maintainability of extensions for PHP, with a focus on type and memory safety.</p> <p>Zephir is a language that addresses the major needs of a PHP developer trying to write and compile code that can be executed by PHP. It supports both dynamic and static typing, and some of its features will be familiar to PHP developers.</p> <p>The name Zephir is a contraction of the words Z(end) E(ngine)/PH(P)/I(nte)r(mediate). While this suggests that the pronunciation should be <code>zephyr</code>, the creators of Zephir actually pronounce it zaefire.</p>"},{"location":"introduction/#features","title":"Features","text":"<p>NOTE</p> <p>This version supports PHP 8.0, 8.1, 8.2 and 8.3</p> <p>Zephir's main features include:</p> Feature Description Type system dynamic/static Memory safety pointers or direct memory management are not allowed Compilation model ahead of time Memory model task-local garbage collection"},{"location":"introduction/#hello-world","title":"Hello World!","text":"<p>Every language has its own \"Hello World!\" sample. In Zephir, this introductory example showcases some important features of the language.</p> <p>In Zephir, code must be placed in classes, as the language is intended for creating object-oriented libraries/frameworks. Code outside a class is not allowed. Additionally, a namespace is required:</p> <pre><code>namespace Test;\n\n/**\n * This is a sample class\n */\nclass Hello\n{\n    /**\n     * This is a sample method\n     */\n    public function say()\n    {\n        echo \"Hello World!\";\n    }\n}\n</code></pre> <p>Once this class is compiled, it will produce the following code, transparently compiled by gcc/clang/vc++:</p> <pre><code>#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_test.h\"\n#include \"test.h\"\n\n#include \"kernel/main.h\"\n\n/**\n * This is a sample class\n */\nZEPHIR_INIT_CLASS(Test_Hello) {\n    ZEPHIR_REGISTER_CLASS(Test, Hello, hello, test_hello_method_entry, 0);\n    return SUCCESS;\n}\n\n/**\n * This is a sample method\n */\nPHP_METHOD(Test_Hello, say) {\n    php_printf(\"%s\", \"Hello World!\");\n}\n</code></pre> <p>We do not expect that a developer using Zephir must know or even understand C. However, if you have experience with compilers, PHP internals, or the C language, that will provide a clearer understanding of what's going on internally when working with Zephir.</p>"},{"location":"introduction/#a-taste-of-zephir","title":"A Taste of Zephir","text":"<p>In the following examples, we'll describe just enough of the details to understand what's going on. The goal is to give you a sense of what programming in Zephir is like. We'll explore the details of the features in subsequent chapters.</p> <p>The following example is very simple; it implements a class and a method, with a small program that checks the types of an array.</p> <p>Let's examine the code in detail, so we can begin to learn Zephir syntax. There are a lot of details in just a few lines of code! We'll explain the general ideas here:</p> <pre><code>namespace Test;\n\n/**\n * MyTest (test/mytest.zep)\n */\nclass MyTest\n{\n    public function someMethod()\n    {\n        /* Variables must be declared */\n        var myArray;\n        int i = 0, length;\n\n        /* Create an array */\n        let myArray = [\"hello\", 0, 100.25, false, null];\n\n        /* Count the array into a 'int' variable */\n        let length = count(myArray);\n\n        /* Print value types */\n        while i &lt; length {\n            echo typeof myArray[i], \"\\n\";\n            let i++;\n        }\n\n        return myArray;\n    }\n}\n</code></pre> <p>In the method, the first lines use the <code>var</code> and <code>int</code> keywords. There are used to declare a variable in the local scope. Every variable used in a method must be declared with its respective type. This declaration is not optional - it helps the compiler warn you about mistyped variables, or about the use of variables out of scope, which usually ends in runtime errors.</p> <p>Dynamic variables are declared with the keyword <code>var</code>. These variables can be assigned and reassigned to different types. On the other hand, the <code>i</code> and <code>length</code> variables are statically typed integer variables, that can only have integer values in the entire program execution.</p> <p>In contrast with PHP, you are not required to put a dollar sign ($) in front of variable names.</p> <p>Zephir follows the same comment conventions as Java, C#, C++, etc. A <code>// comment</code> goes to the end of a line, while a <code>/* comment */</code> can cross line boundaries.</p> <p>Variables are, by default, immutable. This means that Zephir expects that most variables will stay unchanged. Variables that maintain their initial value can be optimized down by the compiler to static constants. When the variable value needs to be changed, the keyword <code>let</code> must be used:</p> <pre><code>/* Create an array */\nlet myArray = [\"hello\", 0, 100.25, false, null];\n</code></pre> <p>By default, arrays are dynamically typed like in PHP - they may contain values of different types. Functions from the PHP userland can be called in Zephir code. In the next example, the function <code>count</code> is called, but the compiler can perform optimizations like avoiding this call, because it already knows the size of the array:</p> <pre><code>/* Count the array into a 'int' variable */\nlet length = count(myArray);\n</code></pre> <p>Parentheses in control flow statements are optional. You can use them if you feel more comfortable doing so, but you aren't required to.</p> <pre><code>while i &lt; length {\n    echo typeof myArray[i], \"\\n\";\n    let i++;\n}\n</code></pre> <p>Since PHP only works with dynamic variables, methods always return dynamic variables. This means that if a statically typed variable is returned, in the PHP side you will get a dynamic variable that can be used in PHP code. Note that memory is automatically managed by the compiler, similarly to how PHP does it, so you don't need to allocate or free memory like in C.</p>"},{"location":"introduction/#external-links","title":"External Links","text":"<p>Some external resources that might be of interest:</p> <ul> <li>Type system</li> <li>Memory safety</li> <li>Ahead-of-time compilation</li> <li>Memory management</li> </ul>"},{"location":"language/","title":"Basic Syntax","text":"<p>In this section, we'll delve into the fundamental aspects of Zephir's syntax, covering topics such as file and namespace organization, variable declarations, syntax conventions, and other essential concepts.</p>"},{"location":"language/#organizing-code-in-files-and-namespaces","title":"Organizing Code in Files and Namespaces","text":"<p>Zephir introduces a structured approach to code organization. Each file should contain only one class, and every class must be within a namespace. The directory structure aligns with class and namespace names, similar to PSR-4 autoloading conventions.</p> <p>For example:</p> <pre><code>mylibrary/\n    router/\n        exception.zep # MyLibrary\\Router\\Exception\n    router.zep # MyLibrary\\Router\n</code></pre> <p>Class in <code>mylibrary/router.zep</code>:</p> <pre><code>namespace MyLibrary;\n\nclass Router\n{\n\n}\n</code></pre> <p>Class in <code>mylibrary/router/exception.zep</code>:</p> <pre><code>namespace MyLibrary\\Router;\n\nclass Exception extends \\Exception\n{\n\n}\n</code></pre> <p>The file system structure must mirror the namespaces, ensuring consistency.</p>"},{"location":"language/#instruction-separation","title":"Instruction separation","text":"<p>In Zephir, semicolons can be used to separate statements and expressions, akin to Java, C/C++, and PHP:</p> <pre><code>myObject-&gt;myMethod(1, 2, 3); echo \"world\";\n</code></pre>"},{"location":"language/#comments","title":"Comments","text":"<p>Zephir supports 'C'/'C++' style comments - single-line with <code>// ...</code> and multi-line with <code>/* ... */</code>:</p> <pre><code>// this is a one line comment\n\n/**\n * multi-line comment\n */\n</code></pre> <p>Multi-line comments also serve as docblocks, influencing the generated code and providing documentation.</p>"},{"location":"language/#variable-declarations","title":"Variable Declarations","text":"<p>In Zephir, all variables used in a given scope must be declared. This gives important information to the compiler to perform optimizations and validations. Variables must be unique identifiers, and they cannot be reserved words.</p> <pre><code>// Declaring variables for the same type    in the same instruction\nvar a, b, c;\n\n// Declaring each variable in separate lines\nvar a;\nvar b;\nvar c;\n</code></pre> <p>Variables can have optional initial default values:</p> <pre><code>// Declaring variables with default values\nvar a = \"hello\", b = 0, c = 1.0;\nint d = 50; bool some = true;\n</code></pre> <p>Variable names are case-sensitive, the following variables are different:</p> <pre><code>// Different variables\nvar somevalue, someValue, SomeValue;\n</code></pre>"},{"location":"language/#variable-scope","title":"Variable Scope","text":"<p>Variables declared are locally scoped to the method where they are defined:</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n    public function someMethod1()\n    {\n        int a = 1, b = 2;\n        return a + b;\n    }\n\n    public function someMethod2()\n    {\n        int a = 3, b = 4;\n        return a + b;\n    }\n}\n</code></pre>"},{"location":"language/#super-globals","title":"Super Globals","text":"<p>Global variables are not supported in Zephir. However, access to PHP's super-globals is possible:</p> <pre><code>// Getting a value from _POST\nlet price = _POST[\"price\"];\n\n// Read a value from _SERVER\nlet requestMethod = _SERVER[\"REQUEST_METHOD\"];\n</code></pre>"},{"location":"language/#local-symbol-table","title":"Local Symbol Table","text":"<p>Zephir does not implement the dynamic variable behavior found in PHP. The language does not have a local symbol table, as all variables are compiled into low-level variables without context awareness. To create a variable in the PHP symbol table, a specific syntax is used:</p> <pre><code>// Set variable $name in PHP\nlet {\"name\"} = \"hello\";\n\n// Set variable $price in PHP\nlet name = \"price\";\nlet {name} = 10.2;\n</code></pre>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2013-present Zephir Team</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"lifecycle/","title":"Lifecycle hooks","text":"<p>PHP extensions leverage lifecycle events for common initialization or shutdown tasks. Zephir integrates with these events through hooks, primarily handled in the config.json file. The diagram illustrates the PHP Process/Request Lifecycle, depicting four types of lifecycle hooks: <code>globals</code>, <code>initializers</code>, <code>destructors</code>, and <code>info</code>. This chapter focuses on <code>initializers</code> and <code>destructors</code>.</p> <p></p> <p>Lifecycle hooks are registered in the <code>config.json</code> file. As you can see in the diagram above, there are four types of lifecycle hooks - <code>globals</code>, <code>initializers</code>, <code>destructors</code>, and <code>info</code>. Each of these has its own corresponding root-level setting in the configuration, and both globals and info[phpinfo] have their own chapters. This chapter covers the other two settings.</p> <p>Each hook in the <code>config.json</code> file is an array of objects, which themselves are essentially <code>include</code>/<code>code</code> pairs. The <code>include</code> value will pull in a given C header file, if it hasn't been already, so that the <code>code</code> will have access to its contents. The <code>code</code> value is the logic run by the hook itself, and while you can technically put any valid C in here, it is strongly recommended to put logic longer than one or two lines into a separate C source file (such as the one pulled in along with your <code>include</code>d header file), and use a single-line function call here.</p>"},{"location":"lifecycle/#initializers","title":"initializers","text":"<p>The <code>initializers</code> block in the <code>config.json</code> file includes logic for initialization events. Three key events are targeted: <code>globals</code> for global variable space setup, module for extension-specific initialization, and <code>request</code> for per-request setup.</p> <pre><code>{\n    \"initializers\": [\n        {\n            \"globals\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"setup_globals_deps(TSRMLS_C)\"\n                }\n            ],\n            \"module\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"setup_module_deps(TSRMLS_C)\"\n                }\n            ],\n            \"request\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"some_c_function(TSRMLS_C)\"\n                },\n                {\n                    \"include\": \"my/awful/library.h\",\n                    \"code\": \"some_other_c_function(TSRMLS_C)\"\n                }\n            ]\n        }\n    ]\n}\n</code></pre> <p>This configuration facilitates the execution of custom C code during the initialization process for various scopes.</p>"},{"location":"lifecycle/#destructors","title":"destructors","text":"<p>The <code>destructors</code> block handles cleanup logic during shutdown events. Four events are addressed: <code>request</code> for finalizing data before sending a response, <code>post-request</code> for cleanup after sending a response, <code>module</code> for extension-specific cleanup, and <code>globals</code> for cleaning up the global variable space.</p> <pre><code>{\n    \"destructors\": [\n        {\n            \"request\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"c_function_for_shutting_down(TSRMLS_C)\"\n                },\n                {\n                    \"include\": \"my/awful/library.h\",\n                    \"code\": \"some_other_c_function_than_the_other_ones(TSRMLS_C)\"\n                }\n            ],\n            \"post-request\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"c_function_for_cleaning_up_after_the_response_is_sent(TSRMLS_C)\"\n                }\n            ],\n            \"module\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"release_module_deps(TSRMLS_C)\"\n                }\n            ],\n            \"globals\": [\n                {\n                    \"include\": \"my/awesome/library.h\",\n                    \"code\": \"release_globals_deps(TSRMLS_C)\"\n                }\n            ]\n        }\n    ]\n}\n</code></pre> <p>This configuration enables the execution of custom C code during various shutdown events, ensuring proper cleanup and finalization processes.</p>"},{"location":"motivation/","title":"Why Zephir?","text":"<p>In the ever-evolving landscape of PHP applications, developers face challenges in achieving a delicate balance between stability, performance, and functionality. The core components, often in the form of libraries or frameworks, serve as the foundation for many applications. Zephir emerges as a solution to address the need for fast, robust extensions that enhance performance and resource efficiency.</p>"},{"location":"motivation/#for-php-programmers","title":"For PHP Programmers...","text":"<p>PHP, renowned for web application development, provides high productivity through its dynamically typed and interpreted nature. Zephir's integration with PHP running on the Zend Engine empowers developers to create extensions, offering a balance between the flexibility of PHP and the efficiency of a compiled language. While Zephir introduces a compilation step, it adheres to strict standards, providing improved performance.</p>"},{"location":"motivation/#for-c-programmers","title":"For C Programmers...","text":"<p>C, a powerful and widely-used language, serves as the backbone for PHP. Zephir, inheriting some characteristics from C, ensures a safer environment by eliminating pointers and manual memory management. While Zephir may feel less powerful than C to seasoned C programmers, it offers a friendlier experience, emphasizing safety and ease of use.</p>"},{"location":"motivation/#compilation-vs-interpretation","title":"Compilation vs Interpretation","text":"<p>Zephir's compilation step introduces a slight delay in development, requiring patience for code compilation before execution. However, this approach brings performance benefits without sacrificing the interpretative nature of PHP. Developers have the flexibility to choose which parts of their application to implement in Zephir, achieving a balance between speed and productivity.</p>"},{"location":"motivation/#statically-typed-versus-dynamically-typed-languages","title":"Statically Typed Versus Dynamically Typed Languages","text":"<p>In a statically typed language, a variable is bound to a particular type for its lifetime. Its type can't be changed and it can only reference type-compatible instances and operations. Languages like C/C++ were implemented with this scheme:</p> <pre><code>int a = 0;\na = \"hello\"; // not allowed\n</code></pre> <p>In dynamic typing, the type is bound to the value, not the variable. So, a variable might refer to a value of one type, then be reassigned later to a value of an unrelated type. Javascript/PHP are examples of a dynamically typed languages:</p> <pre><code>var a = 0;\na = \"hello\"; // allowed\n</code></pre> <p>Despite their productivity advantages, dynamic languages may not be the best choices for all applications, particularly for very large code bases and high-performance applications.</p> <p>Optimizing the performance of a dynamic language like PHP is more challenging than for a static language like C. In a static language, optimizers can exploit the type information attached to variables themselves to make decisions. In a dynamic language, fewer such clues are available for the optimizer, making optimization choices harder.</p> <p>While recent advancements in optimizations for dynamic languages are promising (like JIT compilation), they lag behind the state of the art for static languages. So, if you require very high performance, static languages are probably a safer choice.</p> <p>Another small benefit of static languages is the extra checking the compiler performs. A compiler can't find logic errors, which are far more significant, but a compiler can find errors in advance that in a dynamic language only can be found in runtime.</p> <p>Zephir is both statically and dynamically typed, allowing you to take advantage of both approaches where possible.</p>"},{"location":"motivation/#compilation-scheme","title":"Compilation Scheme","text":"<p>Zephir employs native code generation, compiling to C and utilizing compilers like gcc/clang/vc++ to optimize and produce machine code. This compilation scheme harnesses the capabilities of mature compilers, benefiting from various optimizations provided by these tools.</p> <p></p> <p>In addition to the ones provided by Zephir, over time, compilers have implemented and matured a number of optimizations that improve the performance of compiled applications:</p> <ul> <li>GCC optimizations</li> <li>LLVM passes</li> <li>Visual C/C++ optimizations</li> </ul>"},{"location":"motivation/#code-protection","title":"Code Protection","text":"<p>Compilation with Zephir not only enhances performance but also provides a level of intellectual protection. By producing native binaries, Zephir allows developers to \"hide\" the original code from users or customers, adding an extra layer of security.</p>"},{"location":"motivation/#conclusion","title":"Conclusion","text":"<p>Zephir doesn't aim to replace PHP or C; instead, it complements them. It serves as a bridge, inviting PHP developers to explore code compilation and static typing while preserving the best aspects of both the C and PHP worlds. Zephir is a strategic tool, seeking opportunities to accelerate application development and enhance user experiences.</p>"},{"location":"oop/","title":"Classes and Objects","text":"<p>Zephir encourages object-oriented programming, allowing the export of methods and classes in extensions. The class structure in Zephir is akin to PHP, supporting various modifiers and features.</p>"},{"location":"oop/#classes","title":"Classes","text":"<p>In Zephir, each file must implement a class or interface. A basic class structure resembles PHP:</p> <pre><code>namespace Test;\n\n/**\n * This is a sample class\n */\nclass MyClass\n{\n\n}\n</code></pre>"},{"location":"oop/#class-modifiers","title":"Class Modifiers","text":"<p>Zephir supports class modifiers like <code>final</code> and <code>abstract</code>:</p> <p><code>final</code>: If a class has this modifier it cannot be extended:</p> <pre><code>namespace Test;\n\n/**\n * This class cannot be extended by another class\n */\nfinal class MyClass\n{\n\n}\n\n/**\n * This class cannot be instantiated\n */\nabstract class MyClass\n{\n\n}\n</code></pre>"},{"location":"oop/#implementing-interfaces","title":"Implementing Interfaces","text":"<p>Zephir classes can implement interfaces, even those from different extensions. A \"stub\" interface is created to implement interfaces from other extensions:</p> <pre><code>// middlewareinterfaceex.zep\nnamespace Test\\Oo\\Extend;\n\nuse Psr\\Http\\Server\\MiddlewareInterface;\n\ninterface MiddlewareInterfaceEx extends MiddlewareInterface\n{\n\n}\n</code></pre> <p>From here we can use the <code>stub</code> interface throughout our extension.</p> <pre><code>/**\n * @test\n */\npublic function shouldExtendMiddlewareInterface()\n{\n    if (!extension_loaded('psr')) {\n        $this-&gt;markTestSkipped(\n            \"The psr extension is not loaded\"\n        );\n    }\n\n    $this-&gt;assertTrue(\n        is_subclass_of(MiddlewareInterfaceEx::class, 'Psr\\Http\\Server\\MiddlewareInterface')\n    );\n}\n</code></pre> <p>NOTE</p> <p>It is the developer's responsibility to ensure that all external references are present before the extension is loaded. So for the example above, one has to load the PSR extension first before the Zephir built extension is loaded.</p>"},{"location":"oop/#implementing-methods","title":"Implementing Methods","text":"<p>The <code>function</code> keyword introduces a method. Methods implement the usual visibility modifiers available in PHP. Explicitly setting a visibility modifier is mandatory in Zephir:</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n\n    public function myPublicMethod()\n    {\n        // ...\n    }\n\n    protected function myProtectedMethod()\n    {\n        // ...\n    }\n\n    private function myPrivateMethod()\n    {\n        // ...\n    }\n}\n</code></pre> <p>Methods can receive required and optional parameters:</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n\n    /**\n     * All parameters are required\n     */\n    public function doSum1(a, b)\n    {\n        return a + b;\n    }\n\n    /**\n     * Only 'a' is required, 'b' is optional and it has a default value\n     */\n    public function doSum2(a, b = 3)\n    {\n        return a + b;\n    }\n\n    /**\n     * Both parameters are optional\n     */\n    public function doSum3(a = 1, b = 2)\n    {\n        return a + b;\n    }\n\n    /**\n     * Parameters are required and their values must be integer\n     */\n    public function doSum4(int a, int b)\n    {\n        return a + b;\n    }\n\n    /**\n     * Static typed with default values\n     */\n    public function doSum4(int a = 4, int b = 2)\n    {\n        return a + b;\n    }\n}\n</code></pre>"},{"location":"oop/#optional-nullable-parameters","title":"Optional nullable parameters","text":"<p>Zephir ensures that the value of a variable remains of the type the variable was declared as. This makes Zephir convert the <code>null</code> value to the closest approximate value:</p> <pre><code>public function foo(int a = null)\n{\n    echo a; // if \"a\" is not passed it prints 0\n}\n\npublic function foo(boolean a = null)\n{\n    echo a; // if \"a\" is not passed it prints false\n}\n\npublic function foo(string a = null)\n{\n    echo a; // if \"a\" is not passed it prints an empty string\n}\n\npublic function foo(array a = null)\n{\n    var_dump(a); // if \"a\" is not passed it prints an empty array\n}\n</code></pre>"},{"location":"oop/#supported-visibilities","title":"Supported Visibilities","text":"<ul> <li>Public: Methods marked as <code>public</code> are exported to the PHP extension; this means that public methods are visible to the PHP code as well to the extension itself.</li> <li>Protected: Methods marked as <code>protected</code> are exported to the PHP extension; this means that protected methods are visible to the PHP code as well to the extension itself. However, protected methods can only be called in the scope of the class or in classes that inherit them.</li> <li>Private: Methods marked as <code>private</code> are not exported to the PHP extension; this means that private methods are only visible to the class where they're implemented.</li> </ul>"},{"location":"oop/#supported-modifiers","title":"Supported Modifiers","text":"<ul> <li><code>static</code>: Methods with this modifier can only be called in a static context (from the class, not an object).</li> <li><code>final</code>: If a method has this modifier it cannot be overriden.</li> <li><code>deprecated</code>: Methods marked as <code>deprecated</code> throw an <code>E_DEPRECATED</code> error when they are called.</li> </ul>"},{"location":"oop/#gettersetter-shortcuts","title":"Getter/Setter shortcuts","text":"<p>Like in C#, you can use <code>get</code>/<code>set</code>/<code>toString</code> shortcuts in Zephir. This feature allows you to easily write setters and getters for properties, without explicitly implementing those methods as such.</p> <p>For example, without shortcuts we would need code like:</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n    protected myProperty;\n\n    protected someProperty = 10;\n\n    public function setMyProperty(myProperty)\n    {\n        let this-&gt;myProperty = myProperty;\n    }\n\n    public function getMyProperty()\n    {\n        return this-&gt;myProperty;\n    }\n\n    public function setSomeProperty(someProperty)\n    {\n        let this-&gt;someProperty = someProperty;\n    }\n\n    public function getSomeProperty()\n    {\n        return this-&gt;someProperty;\n    }\n\n    public function __toString()\n    {\n        return this-&gt;myProperty;\n    }\n}\n</code></pre> <p>You can write the same code using shortcuts as follows:</p> <pre><code>namespace App;\n\nclass MyClass\n{\n    protected myProperty {\n        set, get, toString\n    };\n\n    protected someProperty = 10 {\n        set, get\n    };\n}\n</code></pre> <p>When the code is compiled, those methods are exported as real methods, but you don't have to write them manually.</p>"},{"location":"oop/#return-type-hints","title":"Return Type Hints","text":"<p>Methods in classes and interfaces can have \"return type hints\". These will provide useful extra information to the compiler to inform you about errors in your application. Consider the following example:</p> <pre><code>namespace App;\n\nclass MyClass\n{\n    public function getSomeData() -&gt; string\n    {\n        // this will throw a compiler exception\n        // since the returned value (boolean) does not match\n        // the expected returned type string\n        return false;\n    }\n\n    public function getSomeOther() -&gt; &lt;App\\MyInterface&gt;\n    {\n        // this will throw a compiler exception\n        // if the returned object does not implement\n        // the expected interface App\\MyInterface\n        return new App\\MyObject;\n    }\n\n    public function process()\n    {\n        var myObject;\n\n        // the type-hint will tell the compiler that\n        // myObject is an instance of a class\n        // that implement App\\MyInterface\n        let myObject = this-&gt;getSomeOther();\n\n        // the compiler will check if App\\MyInterface\n        // implements a method called \"someMethod\"\n        echo myObject-&gt;someMethod();\n    }\n}\n</code></pre> <p>A method can have more than one return type. When multiple types are defined, the operator <code>|</code> must be used to separate those types.</p> <pre><code>namespace App;\n\nclass MyClass\n{\n    public function getSomeData(a) -&gt; string | bool\n    {\n        if a == false {\n            return false;\n        }\n        return \"error\";\n    }\n}\n</code></pre>"},{"location":"oop/#return-type-void","title":"Return Type: Void","text":"<p>Methods can also be marked as <code>void</code>. This means that a method is not allowed to return any data:</p> <pre><code>public function setConnection(connection) -&gt; void\n{\n    let this-&gt;_connection = connection;\n}\n</code></pre> <p>Why is this useful? Because the compiler can detect if the program is expecting a return value from these methods, and produce a compiler exception:</p> <pre><code>let myDb = db-&gt;setConnection(connection); // this will produce an exception\nmyDb-&gt;execute(\"SELECT * FROM robots\");\n</code></pre>"},{"location":"oop/#strictflexible-parameter-data-types","title":"Strict/Flexible Parameter Data-Types","text":"<p>Zephir allows specifying parameter data types, and by default, they are flexible. However, developers can set specific behavior by using strict data types:</p> <pre><code>public function filterText(string text, boolean escape=false)\n{\n    //...\n}\n</code></pre> <p>Above method will work with the following calls:</p> <pre><code>&lt;?php\n\n$o-&gt;filterText(1111, 1);              // OK\n$o-&gt;filterText(\"some text\", null);    // OK\n$o-&gt;filterText(null, true);           // OK\n$o-&gt;filterText(\"some text\", true);    // OK\n$o-&gt;filterText(array(1, 2, 3), true); // FAIL\n</code></pre> <p>However, passing a wrong type could often lead to bugs. Improper use of a specific API would produce unexpected results. You can disallow the automatic conversion by setting the parameter with a strict data-type:</p> <pre><code>public function filterText(string text, boolean escape=false)\n{\n    //...\n}\n</code></pre> <p>Now, most of the calls with a wrong type will cause an exception due to the invalid data types passed:</p> <pre><code>&lt;?php\n\n$o-&gt;filterText(1111, 1);              // FAIL\n$o-&gt;filterText(\"some text\", null);    // OK\n$o-&gt;filterText(null, true);           // FAIL\n$o-&gt;filterText(\"some text\", true);    // OK\n$o-&gt;filterText(array(1, 2, 3), true); // FAIL\n</code></pre> <p>By specifying which parameters are strict and what can be flexible, a developer can set the specific behavior he/she wants.</p>"},{"location":"oop/#read-only-parameters","title":"Read-Only Parameters","text":"<p>Using the keyword <code>const</code> you can mark parameters as read-only, this helps to respect const-correctness. Parameters marked with this attribute cannot be modified inside the method:</p> <pre><code>namespace App;\n\nclass MyClass\n{\n    // \"a\" is read-only\n    public function getSomeData(const string a)\n    {\n        // this will throw a compiler exception\n        let a = \"hello\";\n    }\n}\n</code></pre> <p>When a parameter is declared as read-only, the compiler can make safe assumptions and perform further optimizations over these variables.</p>"},{"location":"oop/#implementing-properties","title":"Implementing Properties","text":"<p>Class member variables are called \"properties\". By default, they act the same as PHP properties. Properties are exported to the PHP extension, and are visible from PHP code. Properties implement the usual visibility modifiers available in PHP, and explicitly setting a visibility modifier is mandatory in Zephir:</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n    public myProperty1;\n\n    protected myProperty2;\n\n    private myProperty3;\n}\n</code></pre> <p>Within class methods, non-static properties may be accessed by using <code>-&gt;</code> (Object Operator):</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n\n    protected myProperty;\n\n    public function setMyProperty(var myProperty)\n    {\n        let this-&gt;myProperty = myProperty;\n    }\n\n    public function getMyProperty()\n    {\n        return this-&gt;myProperty;\n    }\n}\n</code></pre> <p>Properties can have literal compatible default values. These values must be able to be evaluated at compile time and must not depend on run-time information in order to be evaluated:</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n\n    protected myProperty1 = null;\n    protected myProperty2 = false;\n    protected myProperty3 = 2.0;\n    protected myProperty4 = 5;\n    protected myProperty5 = \"my value\";\n}\n</code></pre>"},{"location":"oop/#updating-properties","title":"Updating Properties","text":"<p>Properties can be updated by accessing them using the <code>-&gt;</code> operator:</p> <pre><code>let this-&gt;myProperty = 100;\n</code></pre> <p>Zephir checks that properties exist when a program is accessing them. If a property is not declared, you will get a compiler exception:</p> <pre><code>CompilerException: Property '_optionsx' is not defined on class 'App\\MyClass' in /Users/scott/utils/app/myclass.zep on line 62\n\n      let this-&gt;_optionsx = options;\n      ------------^\n</code></pre> <p>If you want to avoid this compiler validation, or just create a property dynamically, you can enclose the property name using brackets and string quotes:</p> <pre><code>let this-&gt;{\"myProperty\"} = 100;\n</code></pre> <p>You can also use a simple variable to update a property; the property name will be taken from the variable:</p> <pre><code>let someProperty = \"myProperty\";\nlet this-&gt;{someProperty} = 100;\n</code></pre>"},{"location":"oop/#reading-properties","title":"Reading Properties","text":"<p>Properties can be read by accessing them using the <code>-&gt;</code> operator:</p> <pre><code>echo this-&gt;myProperty;\n</code></pre> <p>As when updating, properties can be dynamically read this way:</p> <pre><code>// Avoid compiler check or read a dynamic user defined property\necho this-&gt;{\"myProperty\"};\n\n// Read using a variable name\nlet someProperty = \"myProperty\";\necho this-&gt;{someProperty}\n</code></pre>"},{"location":"oop/#class-constants","title":"Class Constants","text":"<p>Classes may contain class constants that remain the same and unchangeable once the extension is compiled. Class constants are exported to the PHP extension, allowing them to be used from PHP.</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n    const MYCONSTANT1 = false;\n    const MYCONSTANT2 = 1.0;\n}\n</code></pre> <p>Class constants can be accessed using the class name and the static operator <code>::</code>:</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n\n    const MYCONSTANT1 = false;\n    const MYCONSTANT2 = 1.0;\n\n    public function someMethod()\n    {\n        return MyClass::MYCONSTANT1;\n    }\n}\n</code></pre>"},{"location":"oop/#calling-methods","title":"Calling Methods","text":"<p>Methods can be called using the object operator <code>-&gt;</code> as in PHP:</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n    protected function _someHiddenMethod(a, b)\n    {\n        return a - b;\n    }\n\n    public function someMethod(c, d)\n    {\n        return this-&gt;_someHiddenMethod(c, d);\n    }\n}\n</code></pre> <p>Static methods must be called using the static operator <code>::</code>:</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n    protected static function _someHiddenMethod(a, b)\n    {\n        return a - b;\n    }\n\n    public static function someMethod(c, d)\n    {\n        return self::_someHiddenMethod(c, d);\n    }\n}\n</code></pre> <p>You can call methods in a dynamic manner as follows:</p> <pre><code>namespace Test;\n\nclass MyClass\n{\n    protected adapter;\n\n    public function setAdapter(var adapter)\n    {\n        let this-&gt;adapter = adapter;\n    }\n\n    public function someMethod(var methodName)\n    {\n        return this-&gt;adapter-&gt;{methodName}();\n    }\n}\n</code></pre>"},{"location":"oop/#parameters-by-name","title":"Parameters by Name","text":"<p>Zephir supports calling method parameters by name or keyword arguments. Named parameters can be useful if you want to pass parameters in an arbitrary order, document the meaning of parameters, or specify parameters in a more elegant way.</p> <p>Consider the following example. A class called <code>Image</code> has a method that receives four parameters:</p> <pre><code>namespace Test;\n\nclass Image\n{\n    public function chop(width = 600, height = 400, x = 0, y = 0)\n    {\n        //...\n    }\n}\n</code></pre> <p>Using the standard method calling approach:</p> <pre><code>i-&gt;chop(100);             // width=100, height=400, x=0, y=0\ni-&gt;chop(100, 50, 10, 20); // width=100, height=50, x=10, y=20\n</code></pre> <p>Using named parameters, you can:</p> <pre><code>i-&gt;chop(width: 100);              // width=100, height=400, x=0, y=0\ni-&gt;chop(height: 200);             // width=600, height=200, x=0, y=0\ni-&gt;chop(height: 200, width: 100); // width=100, height=200, x=0, y=0\ni-&gt;chop(x: 20, y: 30);            // width=600, height=400, x=20, y=30\n</code></pre> <p>When the compiler (at compile time) does not know the correct order of these parameters, they must be resolved at runtime. In this case, there could be a minimum additional extra overhead:</p> <pre><code>let i = new {someClass}();\ni-&gt;chop(y: 30, x: 20);\n</code></pre>"},{"location":"operator-precedence/","title":"Operator Precedence","text":"<p>Operator precedence is crucial in determining how expressions are parsed and evaluated. It dictates the order in which operators are applied when multiple operators are present in an expression. For example, in the expression <code>1 + 5 * 3</code>, the answer is 16 and not 18 because the multiplication (<code>*</code>) operator has a higher precedence than the addition (<code>+</code>) operator. Parentheses may be used to force precedence, if necessary. For instance: <code>(1 + 5) * 3</code> evaluates to 18.</p> <p>Here's a breakdown of operator precedence in Zephir:</p>"},{"location":"operator-precedence/#precedence-table","title":"Precedence Table","text":"<p>The table below lists operators in order of precedence, from highest to lowest. Operators on the same line have equal precedence.</p> Precedence Operators Operator type Associativity 1 <code>-&gt;</code> Member Access right-to-left 2 <code>~</code> Bitwise NOT right-to-left 3 <code>!</code> Logical NOT right-to-left 4 <code>new</code> new non-associative 5 <code>clone</code> clone right-to-left 6 <code>typeof</code> Type-of right-to-left 7 <code>..</code>, <code>...</code> Inclusive/exclusive range left-to-right 8 <code>isset</code>, <code>fetch</code>, <code>empty</code> Exclusive range right-to-left 9 <code>*</code>, <code>/</code>, <code>%</code> Multiplication, Division, Remainder left-to-right 10 <code>+</code>, <code>-</code>, <code>.</code> Addition, Subtraction, Concat left-to-right 11 <code>&lt;&lt;</code>, <code>&gt;&gt;</code> Bitwise shift left/right left-to-right 12 <code>&lt;</code>, <code>&lt;=</code>, <code>=&gt;</code>, <code>&gt;</code> Comparison left-to-right 13 <code>==</code>, <code>!==</code>, <code>===</code>, <code>!==</code> Comparison left-to-right 14 <code>&amp;</code> Bitwise AND, references left-to-right 15 <code>^</code> Bitwise XOR left-to-right 16 <code>|</code> Bitwise OR left-to-right 17 <code>instanceof</code> Instance-of left-to-right 18 <code>&amp;&amp;</code> Logical AND left-to-right 19 <code>||</code> Logical OR left-to-right 20 <code>likely</code>, <code>unlikely</code> Branch prediction right-to-left 21 <code>?</code> Logical right-to-left 21 <code>=&gt;</code> Closure Arrow right-to-left"},{"location":"operator-precedence/#associativity","title":"Associativity","text":"<p>Associativity determines how operators with equal precedence are grouped. It specifies the order in which operators are evaluated when they have the same precedence. The associativity is either left-to-right or right-to-left.</p> <p>For example, <code>-</code> is left-associative, so <code>1 - 2 - 3</code> is grouped as <code>(1 - 2) - 3</code> and evaluates to <code>-4</code>. On the other hand, <code>=</code> is right-associative, so <code>let a = b = c</code> is grouped as <code>let a = (b = c)</code>.</p>"},{"location":"operator-precedence/#non-associative-operator","title":"Non-Associative Operator","text":"<p>In Zephir, <code>new</code> is a non-associative operator. This means that using it consecutively without explicit grouping is not allowed. For instance:</p> <pre><code>new new Foo();\n</code></pre> <p>This expression is illegal in Zephir because the <code>new</code> operator is non-associative.</p> <p>Understanding operator precedence and associativity is essential for writing correct and predictable expressions in Zephir. Explicitly using parentheses when needed can improve code readability.</p>"},{"location":"operators/","title":"Operators","text":"<p>Zephir, a language designed for building PHP extensions, comes with a set of operators inherited from PHP, each serving specific purposes. Let's delve into the various operator categories and examples:</p>"},{"location":"operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<p>Zephir supports standard arithmetic operators:</p> Operation Example Negation <code>-a</code> Addition <code>a + b</code> Subtraction <code>a - b</code> Multiplication <code>a * b</code> Division <code>a / b</code> Modulus <code>a % b</code> <pre><code>let result = -a + b * (c - d) / e % f;\n</code></pre>"},{"location":"operators/#bitwise-operators","title":"Bitwise Operators","text":"<p>These operators work with individual bits:</p> Operation Example And <code>a &amp; b</code> Or (inclusive or) <code>a | b</code> Xor (exclusive or) <code>a ^ b</code> Not <code>~a</code> Shift left <code>a &lt;&lt; b</code> Shift right <code>a &gt;&gt; b</code> <p>Example:</p> <pre><code>if a &amp; SOME_FLAG {\n    echo \"has some flag\";\n}\n</code></pre> <p>Learn more about comparison of dynamic variables in the php manual.</p>"},{"location":"operators/#comparison-operators","title":"Comparison Operators","text":"<p>Comparison operators depend on the type of variables compared. For example, if both compared operands are dynamic variables, the behavior is the same as in PHP:</p> Example Operation Description <code>a == b</code> Equal <code>true</code> if a is equal to b after type juggling. <code>a === b</code> Identical <code>true</code> if a is equal to b, and they are of the same type. <code>a != b</code> Not equal <code>true</code> if a is not equal to b after type juggling. <code>a &lt;&gt; b</code> Not equal <code>true</code> if a is not equal to b after type juggling. <code>a !== b</code> Not identical <code>true</code> if a is not equal to b, or they are not of the same type. <code>a &lt; b</code> Less than <code>true</code> if a is strictly less than b. <code>a &gt; b</code> Greater than <code>true</code> if a is strictly greater than b. <code>a &lt;= b</code> Less than or equal to <code>true</code> if a is less than or equal to b. <code>a &gt;= b</code> Greater than or equal to <code>true</code> if a is greater than or equal to b. <p>Example:</p> <pre><code>if a == b {\n    return 0;\n} else {\n    if a &lt; b {\n        return -1;\n    } else {\n        return 1;\n    }\n}\n</code></pre>"},{"location":"operators/#logical-operators","title":"Logical Operators","text":"<p>Dealing with boolean values:</p> Operation Example And <code>a &amp;&amp; b</code> Or <code>a || b</code> Not <code>!a</code> <p>Example:</p> <pre><code>if a &amp;&amp; b || !c {\n    return -1;\n}\nreturn 1;\n</code></pre>"},{"location":"operators/#ternary-operator","title":"Ternary Operator","text":"<p>Equivalent to C or PHP:</p> <pre><code>// b is set to \"x\" if a is equal to 1, otherwise \"y\" is assigned as the value\nlet b = a == 1 ? \"x\" : \"y\"; \n</code></pre>"},{"location":"operators/#special-operators","title":"Special Operators","text":""},{"location":"operators/#empty","title":"Empty","text":"<p>This operator allows checking whether an expression is empty. 'Empty' means the expression is <code>null</code>, is an empty string, or an empty array:</p> <pre><code>let someVar = \"\";\nif empty someVar {\n    echo \"is empty!\";\n}\n\nlet someVar = \"hello\";\nif !empty someVar {\n    echo \"is not empty!\";\n}\n</code></pre>"},{"location":"operators/#fetch","title":"Fetch","text":"<p>'Fetch' is an operator that reduces a common operation in PHP into a single instruction:</p> <pre><code>&lt;?php\n\nif (isset($myArray[$key])) {\n    $value = $myArray[$key];\n    echo $value;\n}\n</code></pre> <p>In Zephir, you can write the same code as:</p> <pre><code>if fetch value, myArray[key] {\n    echo value;\n}\n</code></pre> <p>'Fetch' only returns <code>true</code> if the 'key' is a valid item in the array, and only in that case is 'value' populated.</p>"},{"location":"operators/#isset","title":"Isset","text":"<p>This operator checks whether a property or index has been defined in an array or object:</p> <pre><code>let someArray = [\"a\": 1, \"b\": 2, \"c\": 3];\nif isset someArray[\"b\"] { // check if the array has an index \"b\"\n    echo \"yes, it has an index 'b'\\n\";\n}\n</code></pre> <p>Using <code>isset</code> as a return expression:</p> <pre><code>return isset this-&gt;{someProperty};\n</code></pre> <p>Note that <code>isset</code> in Zephir works more like PHP's function array_key_exists, <code>isset</code> in Zephir returns true even if the array index or property is null.</p>"},{"location":"operators/#typeof","title":"Typeof","text":"<p>This operator checks a variable's type. 'typeof' can be used with a comparison operator:</p> <pre><code>if (typeof str == \"string\") { // or !=\n    echo str;\n}\n</code></pre> <p>It can also work like the PHP function <code>gettype</code>.</p> <pre><code>return typeof str;\n</code></pre> <p>Be careful, if you want to check whether an object is 'callable', you always have to use <code>typeof</code> as a comparison operator, not a function.</p>"},{"location":"operators/#type-hints","title":"Type Hints","text":"<p>Zephir always tries to check whether an object implements methods and properties called/accessed on a variable that is inferred to be an object:</p> <pre><code>let o = new MyObject();\n\n// Zephir checks if \"myMethod\" is implemented on MyObject\no-&gt;myMethod();\n</code></pre> <p>However, due to the dynamism inherited from PHP, sometimes it is not easy to know the class of an object, so Zephir can't produce error reports effectively. A type hint tells the compiler which class is related to a dynamic variable, allowing the compiler to perform more compilation checks:</p> <pre><code>// Tell the compiler that \"o\"\n// is an instance of class MyClass\nlet o = &lt;MyClass&gt; this-&gt;_myObject;\no-&gt;myMethod();\n</code></pre> <p>These \"type hints\" are weak. This means the program does not check if the value is in fact an instance of the specified class, nor whether it implements the specified interface. If you want it to check this every time in execution, use a strict type:</p> <pre><code>// Always check if the property is an instance\n// of MyClass before the assignment\nlet o = &lt;MyClass!&gt; this-&gt;_myObject;\no-&gt;myMethod();\n</code></pre>"},{"location":"operators/#branch-prediction-hints","title":"Branch Prediction Hints","text":"<p>What is branch prediction? Check this article or refer to the Wikipedia article. In environments where performance is very important, it may be useful to introduce these hints.</p> <p>Consider the following example:</p> <pre><code>let allPaths = [];\nfor path in this-&gt;_paths {\n    if path-&gt;isAllowed() == false {\n        throw new App\\Exception(\"Some error message here\");\n    } else {\n        let allPaths[] = path;\n    }\n}\n</code></pre> <p>The authors of the above code know in advance that the condition that throws the exception is unlikely to happen. This means that, 99.9% of the time, our method executes that condition, but it is probably never evaluated as true. For the processor, this could be hard to know, so we could introduce a hint there:</p> <pre><code>let allPaths = [];\nfor path in this-&gt;_paths {\n    if unlikely path-&gt;isAllowed() == false {\n        throw new App\\Exception(\"Some error message here\");\n    } else {\n        let allPaths[] = path;\n    }\n}\n</code></pre>"},{"location":"optimizations/","title":"Optimizations","text":"<p>Because the code in Zephir is sometimes very high-level, a C compiler might not be able to optimize this code enough.</p> <p>Zephir, thanks to its AOT (ahead-of-time) compiler, is able to optimize the code at compile time, potentially improving its execution time, or reducing the memory required by the program.</p> <p>You can enable optimizations by passing the name prefixed by <code>-f</code>:</p> <pre><code>zephir -fstatic-type-inference -flocal-context-pass\n</code></pre> <p>Optimizations can be disabled by passing the name prefixed by <code>-fno-</code>:</p> <pre><code>zephir -fno-static-type-inference -fno-call-gatherer-pass\n</code></pre> <p>Optimizations also can be configured in the config file <code>config.json</code> as follows: <pre><code>{\n  \"namespace\": \"mae\",\n  \"name\": \"My Awesome Extension\",\n  \"author\": \"ACME\",\n  \"version\": \"1.0.0\",\n\n  \"optimizations\": {\n    \"static-type-inference\": true,\n    \"static-type-inference-second-pass\": true,\n    \"local-context-pass\": true,\n    \"constant-folding\": true,\n    \"static-constant-class-folding\": true,\n    \"call-gatherer-pass\": true,\n    \"check-invalid-reads\": false,\n    \"private-internal-methods\": false,\n    \"public-internal-methods\": false,\n    \"public-internal-functions\": true\n  }\n}\n</code></pre></p> <p>The following optimizations are supported:</p>"},{"location":"optimizations/#call-gatherer-pass","title":"<code>call-gatherer-pass</code>","text":"<p>This pass counts how many times a function or method is called within the same method. This allows the compiler to introduce inline caches to avoid method or function lookups:</p> <pre><code>class MyClass extends OtherClass\n{\n\n    public function getValue()\n    {\n        this-&gt;someMethod();\n        this-&gt;someMethod(); // This method is called faster\n    }\n}\n</code></pre>"},{"location":"optimizations/#check-invalid-reads","title":"<code>check-invalid-reads</code>","text":"<p>This flag will force checking types to detect for invalid reads during the compilation process. This ensures that all variables are properly defined and initialized with their default values (as well as the internal pointers). An example is:</p> <pre><code>namespace Acme;\n\nclass ForInRange\n{\n    public static function forEmpty(var n)\n    {\n        var i;\n        for i in range(1, n) {\n            // Do something\n        }\n    }\n}\n</code></pre> <p>compared to:</p> <pre><code>namespace Acme;\n\nclass ForInRange\n{\n    public static function forEmpty(var n)\n    {\n        var i = null;\n        for i in range(1, n) {\n            // Do something\n        }\n    }\n}\n</code></pre> <p>Both examples are perfectly valid as far as Zephir is concerned. The difference is in the generated C code:</p> <pre><code>zval *n;\n\n// ...\n\nzephir_fetch_params(1, 1, 0, &amp;n);\n</code></pre> <p>compared to:</p> <pre><code>zval *n = NULL;\n\n// ...\n\nzephir_fetch_params(1, 1, 0, &amp;n);\n</code></pre> <p>It is a good practice to always initialize variables with default values and types for any programming language. Not doing so, could potentially have unintended consequences for the application, and introduce bugs, memory leaks etc. By using the <code>check-invalid-reads</code> flag in <code>config.json</code> we ensure that pointers are properly initialized along with their respective C variables. Zephir developers will not see a change in their code. This affects the generated C code.</p> <p>More information concerning on why C pointers need to be nullified in Stack overflow here.</p>"},{"location":"optimizations/#constant-folding","title":"<code>constant-folding</code>","text":"<p>Constant folding is the process of simplifying constant expressions at compile time. The following code is simplified when this optimization is enabled:</p> <pre><code>public function getValue()\n{\n    return (86400 * 30) / 12;\n}\n</code></pre> <p>Is transformed into:</p> <pre><code>public function getValue()\n{\n    return 216000;\n}\n</code></pre>"},{"location":"optimizations/#internal-call-transformation","title":"<code>internal-call-transformation</code>","text":"<p>The <code>internal-call-transformation</code> is required to generate internal methods, based on their equivalent PHP ones, allowing for the bypass of the PHP userspace for those internal method calls. By default, this optimization is turned off.</p> <p>This optimization generates 2 implementations per method, one that is exposed in PHP and an internal one.</p> <p>Exceptions to the above are:</p> <ul> <li>Only PHP methods allowed to be replaced (eg. we can't do this for Phalcon's methods)</li> <li>Closures (<code>__invoke</code>) and <code>__construct</code> are not supported</li> <li>The number of required parameters must exactly match the number of actual parameters</li> <li>Does not work for ZendEngine2 (PHP 5.6)</li> </ul>"},{"location":"optimizations/#local-context-pass","title":"<code>local-context-pass</code>","text":"<p>This compilation pass moves variables that will be allocated in the heap to the stack. This optimization can reduce the number of memory indirections a program has to do.</p>"},{"location":"optimizations/#static-constant-class-folding","title":"<code>static-constant-class-folding</code>","text":"<p>This optimization replaces values of class constants in compile time:</p> <pre><code>class MyClass\n{\n\n    const SOME_CONSTANT = 100;\n\n    public function getValue()\n    {\n        return self::SOME_CONSTANT;\n    }\n}\n</code></pre> <p>Is transformed into:</p> <pre><code>class MyClass\n{\n\n    const SOME_CONSTANT = 100;\n\n    public function getValue()\n    {\n        return 100;\n    }\n}\n</code></pre>"},{"location":"optimizations/#static-type-inference","title":"<code>static-type-inference</code>","text":"<p>This compilation pass is very important, since it looks for dynamic variables that can potentially be transformed into static/primitive types, which are better optimized by the underlying compiler.</p> <p>The following code uses a set of dynamic variables to perform some mathematical calculations:</p> <pre><code>public function someCalculations(var a, var b)\n{\n    var i = 0, t = 1;\n\n    while i &lt; 100 {\n        if i % 3 == 0 {\n            continue;\n        }\n        let t += (a - i), i++;\n    }\n\n    return i + b;\n}\n</code></pre> <p>Variables <code>a</code>, <code>b</code>, and <code>i</code> are used exclusively in mathematical operations, and can thus be transformed into static variables taking advantage of other compilation passes. After this pass, the compiler automatically rewrites this code to:</p> <pre><code>public function someCalculations(int a, int b)\n{\n    int i = 0, t = 1;\n\n    while i &lt; 100 {\n        if i % 3 == 0 {\n            continue;\n        }\n        let t += (a - i), i++;\n    }\n\n    return i + b;\n}\n</code></pre> <p>By disabling this compilation pass, all variables will maintain the type with which they were originally declared, without optimization.</p>"},{"location":"optimizations/#static-type-inference-second-pass","title":"<code>static-type-inference-second-pass</code>","text":"<p>This enables a second type inference pass, which improves the work done based on the data gathered by the first static type inference pass.</p>"},{"location":"optimizers/","title":"Custom optimizers","text":"<p>Most common functions in Zephir use internal optimizers. An 'optimizer' works like an interceptor for function calls. An 'optimizer' replaces calls to a function normally defined in the PHP userland, by direct C calls, which are faster and have a lower overhead, improving performance.</p> <p>To create an optimizer, you have to create a class in the 'optimizers' directory (you can configure this directory's name in <code>config.json</code>; see below). The following naming convention must be used:</p> Function in Zephir Optimizer Class Name Optimizer Path Function in C <code>calculate_pi</code> <code>CalculatePiOptimizer</code> <code>optimizers/CalculatePiOptimizer.php</code> <code>my_calculate_pi</code> <p>Note that an optimizer is written in PHP, not Zephir. It is used during compilation to programmatically generate the appropriate C code for your extension to call. It is responsible for checking that arguments and return types match what the C function actually requires, preventing Zephir from generating invalid C code.</p> <p>This is the basic structure for an 'optimizer':</p> <pre><code>&lt;?php\n\nnamespace Zephir\\Optimizers\\FunctionCall;\n\nuse Zephir\\Call;\nuse Zephir\\CompilationContext;\nuse Zephir\\Compiler\\CompilerException;\nuse Zephir\\Optimizers\\OptimizerAbstract;\n\nclass CalculatePiOptimizer extends OptimizerAbstract\n{\n    public function optimize(array $expression, Call $call, CompilationContext $context)\n    {\n        //...\n    }\n}\n</code></pre> <p>Implementation of optimizers highly depends on the kind of code you want to generate. In our example, we're going to replace the call to this function by a call to a C function. In Zephir, the code used to call this function is:</p> <pre><code>let pi = calculate_pi(1000);\n</code></pre> <p>So, the optimizer will expect just one parameter, we have to validate that to avoid problems later:</p> <pre><code>&lt;?php\n\npublic function optimize(array $expression, Call $call, CompilationContext $context)\n{\n\n    if (!isset($expression['parameters'])) {\n        throw new CompilerException(\"'calculate_pi' requires one parameter\", $expression);\n    }\n\n    if (count($expression['parameters']) &gt; 1) {\n        throw new CompilerException(\"'calculate_pi' requires one parameter\", $expression);\n    }\n\n    //...\n}\n</code></pre> <p>There are functions that are just called and don't return any value. Our function returns a value that is the calculated PI value. So we need to check that the type of the variable used to receive this calculated value is OK:</p> <pre><code>&lt;?php\n\npublic function optimize(array $expression, Call $call, CompilationContext $context)\n{\n\n    if (!isset($expression['parameters'])) {\n        throw new CompilerException(\"'calculate_pi' requires one parameter\", $expression);\n    }\n\n    if (count($expression['parameters']) &gt; 1) {\n        throw new CompilerException(\"'calculate_pi' requires one parameter\", $expression);\n    }\n\n    /**\n     * Process the expected symbol to be returned\n     */\n    $call-&gt;processExpectedReturn($context);\n\n    $symbolVariable = $call-&gt;getSymbolVariable();\n    if (!$symbolVariable-&gt;isDouble()) {\n        throw new CompilerException(\"Calculated PI values only can be stored in double variables\", $expression);\n    }\n\n    //...\n}\n</code></pre> <p>We're checking if the value returned will be stored in a variable of type <code>double</code>; if not, a compiler exception is thrown.</p> <p>The next thing we need to do is process the parameters passed to the function:</p> <pre><code>&lt;?php\n\n$resolvedParams = $call-&gt;getReadOnlyResolvedParams($expression['parameters'], $context, $expression);\n</code></pre> <p>A good practice with Zephir is to create functions that don't modify their parameters. If you are changing the parameters passed, Zephir will need to allocate memory for them, and you have to use <code>getResolvedParams</code> instead of <code>getReadOnlyResolvedParams</code>.</p> <p>Code returned by these methods is valid C code that can be used in the code printer to generate the C function call:</p> <pre><code>&lt;?php\n\n// Generate the C-code\nreturn new CompiledExpression('double', 'calculate_pi( ' . $resolvedParams[0] . ')', $expression);\n</code></pre> <p>All optimizers must return a CompiledExpression instance. This will tell the compiler the type returned by the code, and its related C-code.</p> <p>The complete optimizer code is:</p> <pre><code>&lt;?php\n\nnamespace Zephir\\Optimizers\\FunctionCall;\n\nuse Zephir\\Call;\nuse Zephir\\CompilationContext;\nuse Zephir\\CompiledExpression;\nuse Zephir\\Compiler\\CompilerException;\nuse Zephir\\Optimizers\\OptimizerAbstract;\n\nclass CalculatePiOptimizer extends OptimizerAbstract\n{\n    public function optimize(array $expression, Call $call, CompilationContext $context)\n    {\n        if (!isset($expression['parameters'])) {\n            throw new CompilerException(\"'calculate_pi' requires one parameter\", $expression);\n        }\n\n        if (count($expression['parameters']) &gt; 1) {\n            throw new CompilerException(\"'calculate_pi' requires one parameter\", $expression);\n        }\n\n        /**\n         * Process the expected symbol to be returned\n         */\n        $call-&gt;processExpectedReturn($context);\n\n        $symbolVariable = $call-&gt;getSymbolVariable();\n        if (!$symbolVariable-&gt;isDouble()) {\n            throw new CompilerException(\"Calculated PI values only can be stored in double variables\", $expression);\n        }\n\n        $resolvedParams = $call-&gt;getReadOnlyResolvedParams($expression['parameters'], $context, $expression);\n\n        return new CompiledExpression('double', 'my_calculate_pi(' . $resolvedParams[0] . ')', $expression);\n    }\n}\n</code></pre> <p>The code that implements the function <code>my_calculate_pi</code> is written in C, and must be compiled along with the extension.</p> <p>This code must be placed in the <code>ext/</code> directory wherever you find appropriate; just check that those files do not conflict with the files generated by Zephir.</p> <p>This file must contain the Zend Engine headers, and the C implementation of the function:</p> <pre><code>#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ext.h\"\n\ndouble my_calculate_pi(zval *accuracy) {\n    return 0.0;\n}\n</code></pre> <p>This file must be added at a special section in the config.json file:</p> <pre><code>\"extra-sources\": [\n    \"utils/pi.c\"\n]\n</code></pre> <p>Lastly you will have to specify where Zephir can find your optimizer by using the <code>optimizer-dirs</code> configuration option.</p> <pre><code>\"optimizer-dirs\": [\n    \"optimizers\"\n]\n</code></pre> <p>Check the complete source code of this example here</p>"},{"location":"phpinfo/","title":"Phpinfo() sections","text":"<p>To add more directives and information to the phpinfo() output of your Zephir extension, you can make use of the configuration options in the config.json file. This allows you to provide additional details, environment data, and INI options related to your extension.</p> <p>Here is an example of how to configure this in your <code>config.json</code> file:</p> <pre><code>{\n    \"namespace\": \"your_extension\",\n    \"name\": \"Your Extension\",\n    \"author\": \"Your Name\",\n    \"version\": \"1.0.0\",\n\n    \"ini\": {\n        \"your_extension.some_ini_directive\": \"default_value\",\n        \"your_extension.another_ini_directive\": \"another_default_value\"\n    },\n\n    \"info\": {\n        \"some_information\": \"This is additional information about your extension\",\n        \"another_information\": \"You can add more information here\"\n    }\n}\n</code></pre>"},{"location":"phpinfo/#adding-ini-directives","title":"Adding INI Directives","text":"<p>The <code>ini</code> section allows you to specify INI directives related to your extension. In the example above, two INI directives (<code>your_extension.some_ini_directive</code> and <code>your_extension.another_ini_directive</code>) are defined with their default values.</p>"},{"location":"phpinfo/#adding-additional-information","title":"Adding Additional Information","text":"<p>The <code>info</code> section allows you to provide additional information that will be displayed in the <code>phpinfo()</code> output. You can add any key-value pairs under this section to include relevant details about your extension.</p> <p>After making these configurations, when users run <code>phpinfo()</code>, your extension's section will include the specified INI directives and additional information.</p> <p>Adjust the values and keys according to your extension's needs. This customization helps users understand the configuration options and details related to your Zephir extension.</p> <p>This information will be shown as follows:</p> <p></p>"},{"location":"static-analysis/","title":"Static Analysis","text":"<p>Static analysis in the Zephir compiler is a powerful tool that helps developers identify potential issues and improve code quality before runtime. Two key aspects of static analysis in Zephir are:</p>"},{"location":"static-analysis/#conditional-unassigned-variables","title":"Conditional Unassigned Variables","text":"<p>Zephir's static analysis checks for situations where a variable might be used before it's assigned. Consider the following example:</p> <pre><code>class Utils\n{\n    public function someMethod(b)\n    {\n        string a; char c;\n\n        if b == 10 {\n            let a = \"hello\";\n        }\n\n        // a could be uninitialized here\n        for c in a {\n            echo c, PHP_EOL;\n        }\n    }\n}\n</code></pre> <p>In this example, the variable <code>a</code> is conditionally assigned only when <code>b</code> is equal to <code>10</code>. However, the subsequent loop uses the value of <code>a</code>, and it could be uninitialized. Zephir's static analysis detects this and generates a warning:</p> <pre><code>Warning: Variable 'a' was assigned for the first time in conditional branch,\nconsider initializing it in its declaration in\n/home/scott/test/test/utils.zep on 21 [conditional-initialization]\n\n    for c in a {\n</code></pre> <p>This warning alerts the developer to a potential issue, and Zephir automatically initializes the variable to an empty string to avoid unexpected behavior.</p>"},{"location":"static-analysis/#dead-code-elimination","title":"Dead Code Elimination","text":"<p>Zephir's static analysis identifies unreachable code and performs dead code elimination. Unreachable code is code that can never be executed. Here's an example:</p> <pre><code>class Utils\n{\n    public function someMethod(b)\n    {\n        if false {\n            // This code is never executed\n            echo \"hello\";\n        }\n    }\n}\n</code></pre> <p>In this case, the <code>if false</code> condition ensures that the code inside the block is never executed. Zephir's static analysis detects this and eliminates the dead code, optimizing the generated binary.</p> <p>Using static analysis helps Zephir developers catch potential bugs and improve code quality by providing early warnings and optimizations. This proactive approach contributes to a more reliable and efficient codebase.</p> <p>Zephir's compiler provides static analysis of the compiled code. The idea behind this feature is to help the developer to find potential problems and avoid unexpected behaviors, well before runtime.</p>"},{"location":"static-analysis/#conditional-unassigned-variables_1","title":"Conditional Unassigned Variables","text":"<p>Static Analysis of assignments tries to identify if a variable is used before it's assigned:</p> <pre><code>class Utils\n{\n    public function someMethod(b)\n    {\n        string a; char c;\n\n        if b == 10 {\n            let a = \"hello\";\n        }\n\n        //a could be unitialized here\n        for c in a {\n            echo c, PHP_EOL;\n        }\n    }\n}\n</code></pre> <p>The above example illustrates a common situation. The variable <code>a</code> is assigned only when <code>b</code> is equal to 10, then it's required to use the value of this variable - but it could be uninitialized. Zephir detects this, automatically initializes the variable to an empty string, and generates a warning alerting the developer:</p> <pre><code>Warning: Variable 'a' was assigned for the first time in conditional branch,\nconsider initialize it in its declaration in\n/home/scott/test/test/utils.zep on 21 [conditional-initialization]\n\n    for c in a {\n</code></pre> <p>Finding such errors is sometimes tricky, however static analysis helps the programmer to find bugs in advance.</p>"},{"location":"static-analysis/#dead-code-elimination_1","title":"Dead Code Elimination","text":"<p>Zephir informs the developer about unreachable branches in the code and performs dead code elimination, which means it gets rid of all that code from the generated binary, since it cannot be executed anyway:</p> <pre><code>class Utils\n{\n    public function someMethod(b)\n    {\n        if false {\n            // This is never executed\n            echo \"hello\";\n        }\n    }\n}\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Zephir, and this manual, are intended for PHP developers who want to create C extensions, with a lower complexity.</p> <p>We assume that you are experienced in one or more other programming languages. We draw parallels to features in PHP, C, Javascript, and other languages. We'll point out features in Zephir that are similar to these other languages, as well as many features that are new or different. If you are familiar with these specific languages, you'll pick up on these comparisons more quickly.</p> <p>In this guide, we will use the standard Linux terminal commands. If you are a Windows user, you need to replace these commands with their counterparts.</p>"},{"location":"tutorial/#checking-the-installation","title":"Checking the Installation","text":"<p>If you have successfully installed Zephir, you will be able to execute the following command in your console:</p> <pre><code>zephir help\n</code></pre> <p>If everything is well, you should see the following help (or something very similar):</p> <pre><code> _____              __    _\n/__  /  ___  ____  / /_  (_)____\n  / /  / _ \\/ __ \\/ __ \\/ / ___/\n / /__/  __/ /_/ / / / / / /\n/____/\\___/ .___/_/ /_/_/_/\n         /_/\n\nZephir 0.18.0 by the Phalcon Team\nThanks to the work by: Andres Gutierrez and Serghei Iakovlev (source)\n\nUsage:\n  command [options] [arguments]\n\nOptions:\n      --dumpversion  Print the version of the compiler and don't do anything else (also works with a single hyphen)\n  -h, --help         Print this help message\n      --no-ansi      Disable ANSI output\n  -v, --verbose      Displays more detail in error messages from exceptions generated by commands (can also disable with -V)\n      --vernum       Print the version of the compiler as integer\n      --version      Print compiler version information and quit\n\nAvailable commands:\n  api        Generates a HTML API based on the classes exposed in the extension\n  build      Generates/Compiles/Installs a Zephir extension\n  clean      Cleans any object files created by the extension\n  compile    Compile a Zephir extension\n  fullclean  Cleans any object files created by the extension (including files generated by phpize)\n  generate   Generates C code from the Zephir code without compiling it\n  help       Display help for a command\n  init       Initializes a Zephir extension\n  install    Installs the extension in the extension directory (may require root password)\n  stubs      Generates stubs that can be used in a PHP IDE\n</code></pre> <p>If something went wrong, please return back to the installation page.</p>"},{"location":"tutorial/#extension-skeleton","title":"Extension Skeleton","text":"<p>The first thing we have to do is generate an extension skeleton. This will provide to our extension the basic structure we need to start working. In our case, we're going to create an extension called <code>utils</code>:</p> <pre><code>zephir init utils\n</code></pre> <p>After this, a directory called \"utils\" is created on the current working directory:</p> <pre><code>utils/\n   ext/\n   utils/\n</code></pre> <p>The directory <code>ext/</code> (inside utils) contains the code that is going to be used by the compiler to produce the extension. Another directory created is <code>utils</code> - this directory has the same name as our extension. We will place Zephir code there.</p> <p>We need to change the working directory to \"utils\" to start compiling our code:</p> <pre><code>cd utils\nls\next/ utils/ config.json\n</code></pre> <p>The directory listing will also show us a file called <code>config.json</code>. This file contains configuration settings we can use to alter the behavior of Zephir and/or the extension itself.</p>"},{"location":"tutorial/#adding-our-first-class","title":"Adding our first class","text":"<p>Zephir is designed to generate object-oriented extensions. To start developing functionality, we need to add our first class to the extension.</p> <p>As in many languages/tools, the first thing we want to do is see a <code>hello world</code> generated by Zephir, and check that everything is well. So our first class will be called <code>Utils\\Greeting</code>, and contain a method printing <code>hello world!</code>.</p> <p>The code for this class must be placed in <code>utils/utils/greeting.zep</code>:</p> <pre><code>namespace Utils;\n\nclass Greeting\n{\n\n    public static function say()\n    {\n        echo \"hello world!\";\n    }\n\n}\n</code></pre> <p>Now, we need to tell Zephir that our project must be compiled and the extension generated:</p> <pre><code>zephir build\n</code></pre> <p>Initially, and only for the first time, a number of internal commands are executed producing the necessary code and configurations to export this class to the PHP extension. If everything goes well, you will see the following message at the end of the output:</p> <pre><code>    ...\nExtension installed!\nAdd extension=utils.so to your php.ini\nDon't forget to restart your web server\n</code></pre> <p>At the above step, it's likely that you would need to supply your root password in order to install the extension.</p> <p>Finally, the extension must be added to the <code>php.ini</code> in order to be loaded by PHP. This is achieved by adding the initialization directive: <code>extension=utils.so</code> to it.</p> <p>NOTE: You can also load it on the command line with <code>-d extension=utils.so</code>, but it will only load for that single request, so you'd need to include it every time you want to test your extension in the CLI. Adding the directive to the <code>php.ini</code> will ensure it is loaded for every request from then on.</p>"},{"location":"tutorial/#initial-testing","title":"Initial Testing","text":"<p>Now that the extension was added to your <code>php.ini</code>, check whether the extension is being loaded properly by executing the following:</p> <pre><code>php -m\n[PHP Modules]\nCore\ndate\nlibxml\npcre\nReflection\nsession\nSPL\nstandard\ntokenizer\nutils\nxdebug\nxml\n</code></pre> <p>Extension <code>utils</code> should be part of the output, indicating that the extension was loaded correctly. Now, let's see our <code>hello world</code> directly executed by PHP. To accomplish this, you can create a simple PHP file calling the static method we have just created:</p> <pre><code>&lt;?php\n\necho Utils\\Greeting::say(), \"\\n\";\n</code></pre> <p>Congratulations! \u0423ou have your first extension running in PHP.</p>"},{"location":"tutorial/#a-useful-class","title":"A useful class","text":"<p>The <code>Utils\\Greeting::say</code> method was fine to check if our environment was right. Now, let's create some more useful classes.</p> <p>The first useful class we are going to add to this extension will provide filtering facilities to users. This class is called <code>Utils\\Filter</code> and its code must be placed in <code>utils/utils/filter.zep</code>:</p> <p>A basic skeleton for this class is the following:</p> <pre><code>namespace Utils;\n\nclass Filter\n{\n\n}\n</code></pre> <p>The class contains filtering methods that help users to filter unwanted characters from strings. The first method is called <code>alpha</code>, and its purpose is to filter only those characters that are ASCII basic letters. To begin, we are just going to traverse the string, printing every byte to the standard output:</p> <pre><code>namespace Utils;\n\nclass Filter\n{\n\n    public function alpha(string str)\n    {\n        char ch;\n\n        for ch in str {\n            echo ch, \"\\n\";\n        }\n    }\n}\n</code></pre> <p>When invoking this method:</p> <pre><code>&lt;?php\n\n$f = new Utils\\Filter();\n$f-&gt;alpha(\"hello\");\n</code></pre> <p>You will see:</p> <pre><code>h\ne\nl\nl\no\n</code></pre> <p>Checking every character in the string is straightforward. Now we'll create another string with the right filtered characters:</p> <pre><code>class Filter\n{\n\n    public function alpha(string str) -&gt; string\n    {\n        char ch; string filtered = \"\";\n\n        for ch in str {\n            if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') {\n                let filtered .= ch;\n            }\n        }\n\n        return filtered;\n    }\n}\n</code></pre> <p>The complete method can be tested as before:</p> <pre><code>&lt;?php\n\n$f = new Utils\\Filter();\necho $f-&gt;alpha(\"!he#02l3'121lo.\"); // prints \"hello\"\n</code></pre> <p>In the following screencast you can watch how to create the extension explained in this tutorial:</p>"},{"location":"tutorial/#conclusion","title":"Conclusion","text":"<p>This is a very simple tutorial, and as you can see, it's easy to start building extensions using Zephir. We invite you to continue reading the manual so that you can discover additional features offered by Zephir!</p>"},{"location":"types/","title":"Types","text":"<p>Zephir is both dynamically and statically typed. In this chapter we highlight the supported types and their behaviors.</p>"},{"location":"types/#dynamic-types","title":"Dynamic Types","text":"<p>Dynamic variables are exactly like the ones in PHP. They can be assigned and reassigned to different types without restriction.</p> <p>A dynamic variable must be declared with the keyword <code>var</code>. The behavior is nearly the same as in PHP:</p> <pre><code>var a, b, c;\n</code></pre>"},{"location":"types/#initialize-variables","title":"Initialize variables","text":"<pre><code>let a = \"hello\", b = false;\n</code></pre>"},{"location":"types/#change-their-values","title":"Change their values","text":"<pre><code>let a = \"hello\", b = false;\nlet a = 10, b = \"140\";\n</code></pre>"},{"location":"types/#perform-operations","title":"Perform operations","text":"<pre><code>let c = a + b;\n</code></pre> <p>They can have eight types:</p> Type Description <code>array</code> An array is an ordered map. A map is a type that associates values to keys. <code>boolean</code> A boolean expresses a truth value. It can be either <code>true</code> or <code>false</code>. <code>float</code>/<code>double</code> Floating point numbers. The size of a float is platform-dependent. <code>integer</code> Integer numbers. The size of an integer is platform-dependent. <code>null</code> The special NULL value represents a variable with no value. <code>object</code> Object abstraction like in PHP. <code>resource</code> A resource holds a reference to an external resource. <code>string</code> A string is series of characters, where a character is the same as a byte. <p>Check more info about these types in the PHP manual.</p>"},{"location":"types/#array","title":"Array","text":"<p>The array implementation in Zephir is basically the same as in PHP: ordered maps optimized for several different uses; it can be treated as an array, list (vector), hash table (an implementation of a map), dictionary, collection, stack, queue, and probably more. As array values can be other arrays, trees and multidimensional arrays are also possible.</p> <p>The syntax to define arrays is slightly different than in PHP:</p>"},{"location":"types/#square-braces-must-be-used-to-define-arrays","title":"Square braces must be used to define arrays","text":"<pre><code>let myArray = [1, 2, 3];\n</code></pre>"},{"location":"types/#double-colon-must-be-used-to-define-hashes-keys","title":"Double colon must be used to define hashes' keys","text":"<pre><code>let myHash = [\"first\": 1, \"second\": 2, \"third\": 3];\n</code></pre> <p>Only long and string values can be used as keys:</p> <pre><code>let myHash = [0: \"first\", 1: true, 2: null];\nlet myHash = [\"first\": 7.0, \"second\": \"some string\", \"third\": false];\n</code></pre>"},{"location":"types/#boolean","title":"Boolean","text":"<p>A boolean expresses a truth value. It can be either <code>true</code> or <code>false</code>:</p> <pre><code>var a = false, b = true;\n</code></pre>"},{"location":"types/#floatdouble","title":"Float/Double","text":"<p>Floating-point numbers (also known as \"floats\", \"doubles\", or \"real numbers\"). Floating-point literals are expressions with one or more digits, followed by a period (.), followed by one or more digits. The size of a float is platform-dependent, although a maximum of ~1.8e308 with a precision of roughly 14 decimal digits is a common value (the 64 bit IEEE format).</p> <pre><code>var number = 5.0, b = 0.014;\n</code></pre> <p>Floating point numbers have limited precision. Although it depends on the system, Zephir uses the same IEEE 754 double precision format used by PHP, which will give a maximum relative error due to rounding in the order of 1.11e-16.</p>"},{"location":"types/#integer","title":"Integer","text":"<p>Integer numbers. The size of an integer is platform-dependent, although a maximum value of about two billion is the usual value (that's 32 bits signed). 64-bit platforms usually have a maximum value of about 9E18. PHP does not support unsigned integers so Zephir has this restriction too:</p> <pre><code>var a = 5, b = 10050;\n</code></pre>"},{"location":"types/#integer-overflow","title":"Integer overflow","text":"<p>Contrary to PHP, Zephir does not automatically check for integer overflows. Like in C, if you are doing operations that may return a big number, you should use types such as <code>unsigned long</code> or <code>float</code> to store them:</p> <pre><code>unsigned long my_number = 2147483648;\n</code></pre>"},{"location":"types/#object","title":"Object","text":"<p>Zephir allows to instantiate, manipulate, call methods, read class constants, etc from PHP objects:</p> <pre><code>let myObject = new \\stdClass(),\n    myObject-&gt;someProperty = \"my value\";\n</code></pre>"},{"location":"types/#string","title":"String","text":"<p>A <code>string</code> is series of characters, where a character is the same as a byte. As PHP, Zephir only supports a 256-character set, and hence does not offer native Unicode support.</p> <pre><code>var today = \"friday\";\n</code></pre> <p>In Zephir, string literals can only be specified using double quotes (like in C or Go). Single quotes are reserved for <code>char</code> data type.</p> <p>The following escape sequences are supported in strings:</p> Sequence Description <code>\\t</code> Horizontal tab <code>\\n</code> Line feed <code>\\r</code> Carriage return <code>\\\\</code> Backslash <code>\\\"</code> double-quote <pre><code>var today    = \"\\tfriday\\n\\r\",\n    tomorrow = \"\\tsaturday\";\n</code></pre> <p>In Zephir, strings don't support variable parsing like in PHP; you need to use concatenation instead:</p> <pre><code>var name = \"peter\";\n\necho \"hello: \" . name;\n</code></pre>"},{"location":"types/#static-types","title":"Static Types","text":"<p>Static typing allows the developer to declare and use some variable types available in C. Variables can't change their type once they're declared as static types. However, they allow the compiler to do a better optimization job. The following types are supported:</p> Type Description <code>array</code> A structure that can be used as hash, map, dictionary, collection, stack, etc. <code>boolean</code> A boolean expresses a truth value. It can be either <code>true</code> or <code>false</code>. <code>char</code> Smallest addressable unit of the machine that can contain basic character set. <code>float</code>/<code>double</code> Double precision floating-point type. The size is platform-dependent. <code>integer</code> Signed integers. At least 16 bits in size. <code>long</code> Long signed integer type. At least 32 bits in size. <code>string</code> A string is a series of characters, where a character is the same as a byte. <code>unsigned char</code> Same size as <code>char</code>, but guaranteed to be unsigned. <code>unsigned integer</code> Unsigned integers. At least 16 bits in size. <code>unsigned long</code> Same as <code>long</code>, but unsigned."},{"location":"types/#boolean_1","title":"Boolean","text":"<p>A <code>boolean</code> expresses a truth value. It can be either <code>true</code> or <code>false</code>. Contrary to the dynamic behavior detailed above, static <code>boolean</code> types remain <code>boolean</code> (<code>true</code> or <code>false</code>) no mater what value is assigned to them:</p> <pre><code>boolean a;\nlet a = true;\n</code></pre>"},{"location":"types/#automatically-casted-to-true","title":"automatically casted to <code>true</code>","text":"<pre><code>let a = 100;\n</code></pre>"},{"location":"types/#automatically-casted-to-false","title":"automatically casted to <code>false</code>","text":"<pre><code>let a = 0;\n</code></pre>"},{"location":"types/#throws-a-compiler-exception","title":"throws a compiler exception","text":"<pre><code>let a = \"hello\";\n</code></pre>"},{"location":"types/#charunsigned-char","title":"Char/Unsigned Char","text":"<p><code>char</code> variables are the smallest addressable unit of the machine that can contain the basic character set (generally 8 bits). A <code>char</code> variable can be used to store any character in a string:</p> <pre><code>char ch, string name = \"peter\";\n</code></pre>"},{"location":"types/#stores-t","title":"stores 't'","text":"<pre><code>let ch = name[2];\n</code></pre>"},{"location":"types/#char-literals-must-be-enclosed-in-single-quotes","title":"<code>char</code> literals must be enclosed in single quotes","text":"<pre><code>let ch = 'Z';\n</code></pre>"},{"location":"types/#integerunsigned-integer","title":"Integer/Unsigned Integer","text":"<p><code>integer</code> values are like the <code>integer</code> member in dynamic values. Values assigned to integer variables remain integer:</p> <pre><code>int a;\n\nlet a = 50,\n    a = -70;\n</code></pre>"},{"location":"types/#automatically-casted-to-100","title":"automatically casted to 100","text":"<pre><code>let a = 100.25;\n</code></pre>"},{"location":"types/#automatically-casted-to-0","title":"automatically casted to 0","text":"<pre><code>let a = null;\n</code></pre>"},{"location":"types/#automatically-casted-to-0_1","title":"automatically casted to 0","text":"<pre><code>let a = false;\n</code></pre>"},{"location":"types/#throws-a-compiler-exception_1","title":"throws a compiler exception","text":"<pre><code>let a = \"hello\";\n</code></pre> <p><code>unsigned integer</code> variables are like <code>integer</code> but they don't have sign, this means you can't store negative numbers in these sort of variables:</p> <pre><code>uint a;\n\nlet a = 50;\n</code></pre>"},{"location":"types/#automatically-casted-to-70","title":"automatically casted to 70","text":"<pre><code>let a = -70;\n</code></pre>"},{"location":"types/#automatically-casted-to-100_1","title":"automatically casted to 100","text":"<pre><code>let a = 100.25;\n</code></pre>"},{"location":"types/#automatically-casted-to-0_2","title":"automatically casted to 0","text":"<pre><code>let a = null;\n</code></pre>"},{"location":"types/#automatically-casted-to-0_3","title":"automatically casted to 0","text":"<pre><code>let a = false;\n</code></pre>"},{"location":"types/#throws-a-compiler-exception_2","title":"throws a compiler exception","text":"<pre><code>let a = \"hello\";\n</code></pre> <p><code>unsigned integer</code> variables are twice bigger than standard <code>integer</code>. Assigning <code>unsigned integer</code> to standard (signed) <code>integer</code> may result in loss of data:</p>"},{"location":"types/#potential-loss-of-data-for-b","title":"potential loss of data for <code>b</code>","text":"<pre><code>uint a, int b;\n\nlet a = 2147483648,\n    b = a;\n</code></pre>"},{"location":"types/#longunsigned-long","title":"Long/Unsigned Long","text":"<p><code>long</code> variables are twice bigger than <code>integer</code> variables, thus they can store bigger numbers. As with <code>integer</code>, values assigned to <code>long</code> variables are automatically casted to this type:</p> <pre><code>long a;\n\nlet a = 50,\n    a = -70;\n</code></pre>"},{"location":"types/#automatically-casted-to-100_2","title":"automatically casted to 100","text":"<pre><code>let a = 100.25;\n</code></pre>"},{"location":"types/#automatically-casted-to-0_4","title":"automatically casted to 0","text":"<pre><code>    let a = null;\n</code></pre>"},{"location":"types/#automatically-casted-to-0_5","title":"automatically casted to 0","text":"<pre><code>let a = false;\n</code></pre>"},{"location":"types/#throws-a-compiler-exception_3","title":"throws a compiler exception","text":"<pre><code>let a = \"hello\";\n</code></pre> <p><code>unsigned long</code> are like <code>long</code> but they are not signed, this means you can't store negative numbers in these sort of variables:</p> <pre><code>ulong a;\n\nlet a = 50;\n</code></pre>"},{"location":"types/#automatically-casted-to-70_1","title":"automatically casted to 70","text":"<pre><code>let  a = -70;\n</code></pre>"},{"location":"types/#automatically-casted-to-100_3","title":"automatically casted to 100","text":"<pre><code>let a = 100.25;\n</code></pre>"},{"location":"types/#automatically-casted-to-0_6","title":"automatically casted to 0","text":"<pre><code>let a = null;\n</code></pre>"},{"location":"types/#automatically-casted-to-0_7","title":"automatically casted to 0","text":"<pre><code>let a = false;\n</code></pre>"},{"location":"types/#throws-a-compiler-exception_4","title":"throws a compiler exception","text":"<pre><code>let a = \"hello\";\n</code></pre> <p><code>unsigned long</code> variables are twice bigger than standard <code>long</code>; assigning <code>unsigned long</code> to standard (signed) <code>long</code> may result in loss of data:</p>"},{"location":"types/#potential-loss-of-data-for-b_1","title":"potential loss of data for <code>b</code>","text":"<pre><code>ulong a, long b;\n\nlet a = 4294967296,\n    b = a;\n</code></pre>"},{"location":"types/#string_1","title":"String","text":"<p>A string is series of characters, where a character is the same as a byte. As in PHP it only supports a 256-character set, and hence does not offer native Unicode support.</p> <p>When a variable is declared <code>string</code> it never changes its type:</p> <pre><code>string a;\n\nlet a = \"\";\n</code></pre>"},{"location":"types/#string-literals-must-be-enclosed-in-double-quotes","title":"string literals must be enclosed in double quotes","text":"<pre><code>let  a = \"hello\";\n</code></pre>"},{"location":"types/#converted-to-string-a","title":"converted to string \"A\"","text":"<pre><code>let a = 'A';\n</code></pre>"},{"location":"types/#automatically-casted-to","title":"automatically casted to \"\"","text":"<pre><code>let a = null;\n</code></pre>"},{"location":"warnings/","title":"Compiler Warnings","text":"<p>The compiler raises warnings when it finds situations where the code can be improved, or a potential error can be avoided.</p> <p>Warnings can be enabled via command line parameters, or can be added to the <code>config.json</code> to enable or disable them more permanently.</p> <p>You can enable warnings by passing their name prefixed by <code>-w</code>:</p> <pre><code>zephir -wunused-variable -wnonexistent-function\n</code></pre> <p>Warnings can be disabled by passing their name prefixed by <code>-W</code>:</p> <pre><code>zephir -Wunused-variable -Wnonexistent-function\n</code></pre> <p>The following warnings are supported:</p>"},{"location":"warnings/#unused-variable","title":"unused-variable","text":"<p>Raised when a variable is declared, but it is not used within a method. This warning is enabled by default.</p> <pre><code>public function some()\n{\n    var e; // declared but not used\n\n    return false;\n}\n</code></pre>"},{"location":"warnings/#unused-variable-external","title":"unused-variable-external","text":"<p>Raised when a parameter is declared, but it is not used within a method.</p> <pre><code>public function sum(a, b, c) // c is not used\n{\n    return a + b;\n}\n</code></pre>"},{"location":"warnings/#possible-wrong-parameter-undefined","title":"possible-wrong-parameter-undefined","text":"<p>Raised when a method is called with a wrong type for a parameter:</p> <pre><code>public function some()\n{\n    return this-&gt;sum(\"a string\", \"another\");  // wrong parameters passed\n}\n\npublic function sum(int a, int b)\n{\n    return a + b;\n}\n</code></pre>"},{"location":"warnings/#nonexistent-function","title":"nonexistent-function","text":"<p>Raised when a function is called that does not exist at compile time:</p> <pre><code>public function some()\n{\n    someFunction(); // someFunction does not exist\n}\n</code></pre>"},{"location":"warnings/#nonexistent-class","title":"nonexistent-class","text":"<p>Raised when a class is used that does not exist at compile time:</p> <pre><code>public function some()\n{\n    var a;\n\n    let a = new \\MyClass(); // MyClass does not exist\n}\n</code></pre>"},{"location":"warnings/#non-valid-isset","title":"non-valid-isset","text":"<p>Raised when the compiler detects that an 'isset' operation is being made on a non-array or -object value:</p> <pre><code>public function some()\n{\n    var b = 1.2;\n\n    return isset b[0]; // variable integer 'b' used as array\n}\n</code></pre>"},{"location":"warnings/#non-array-update","title":"non-array-update","text":"<p>Raised when the compiler detects that an array update operation is being made on a non-array value:</p> <pre><code>public function some()\n{\n    var b = 1.2;\n    let b[0] = true; // variable 'b' cannot be used as array\n}\n</code></pre>"},{"location":"warnings/#non-valid-objectupdate","title":"non-valid-objectupdate","text":"<p>Raised when the compiler detects that an object update operation is being made on a non-object value:</p> <pre><code>public function some()\n{\n    var b = 1.2;\n    let b-&gt;name = true; // variable 'b' cannot be used as object\n}\n</code></pre>"},{"location":"warnings/#non-valid-fetch","title":"non-valid-fetch","text":"<p>Raised when the compiler detects that a 'fetch' operation is being made on a non-array or -object value:</p>"},{"location":"warnings/#variable-integer-b-used-as-array","title":"variable integer 'b' used as array","text":"<pre><code>public function some()\n{\n    var b = 1.2, a;\n    fetch a, b[0];\n}\n</code></pre>"},{"location":"warnings/#invalid-array-index","title":"invalid-array-index","text":"<p>Raised when the compiler detects that an invalid array index is used:</p> <pre><code>public function some(var a)\n{\n    var b = [];\n    let a[b] = true;\n}\n</code></pre>"},{"location":"warnings/#non-array-append","title":"non-array-append","text":"<p>Raised when the compiler detects that an element is being appended to a non-array variable:</p> <pre><code>public function some()\n{\n    var b = false;\n    let b[] = \"some value\";\n}\n</code></pre>"}]}